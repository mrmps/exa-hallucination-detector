
=== ./colors.ts ===

// tailwind/colors.js
const colors = {
    // Background colors
    'background': {
      100: 'var(--ds-background-100)',
      200: 'var(--ds-background-200)',
    },
  
    // Gray
    'gray': {
      100: 'var(--ds-gray-100)',
      200: 'var(--ds-gray-200)',
      300: 'var(--ds-gray-300)',
      400: 'var(--ds-gray-400)', 
      500: 'var(--ds-gray-500)',
      600: 'var(--ds-gray-600)',
      700: 'var(--ds-gray-700)',
      800: 'var(--ds-gray-800)',
      900: 'var(--ds-gray-900)',
      1000: 'var(--ds-gray-1000)',
    },
  
    // Gray Alpha
    'gray-alpha': {
      100: 'var(--ds-gray-alpha-100)',
      200: 'var(--ds-gray-alpha-200)',
      300: 'var(--ds-gray-alpha-300)',
      400: 'var(--ds-gray-alpha-400)',
      500: 'var(--ds-gray-alpha-500)',
      600: 'var(--ds-gray-alpha-600)',
      700: 'var(--ds-gray-alpha-700)',
      800: 'var(--ds-gray-alpha-800)',
      900: 'var(--ds-gray-alpha-900)',
      1000: 'var(--ds-gray-alpha-1000)',
    },
  
    // Blue
    'blue': {
      100: 'var(--ds-blue-100)',
      200: 'var(--ds-blue-200)',
      300: 'var(--ds-blue-300)',
      400: 'var(--ds-blue-400)',
      500: 'var(--ds-blue-500)',
      600: 'var(--ds-blue-600)',
      700: 'var(--ds-blue-700)',
      800: 'var(--ds-blue-800)',
      900: 'var(--ds-blue-900)',
      1000: 'var(--ds-blue-1000)',
    },
  
    // Red
    'red': {
      100: 'var(--ds-red-100)',
      200: 'var(--ds-red-200)',
      300: 'var(--ds-red-300)',
      400: 'var(--ds-red-400)',
      500: 'var(--ds-red-500)',
      600: 'var(--ds-red-600)',
      700: 'var(--ds-red-700)',
      800: 'var(--ds-red-800)',
      900: 'var(--ds-red-900)',
      1000: 'var(--ds-red-1000)',
    },
  
    // Amber
    'amber': {
      100: 'var(--ds-amber-100)',
      200: 'var(--ds-amber-200)',
      300: 'var(--ds-amber-300)',
      400: 'var(--ds-amber-400)',
      500: 'var(--ds-amber-500)',
      600: 'var(--ds-amber-600)',
      700: 'var(--ds-amber-700)',
      800: 'var(--ds-amber-800)',
      900: 'var(--ds-amber-900)',
      1000: 'var(--ds-amber-1000)',
    },
  
    // Green
    'green': {
      100: 'var(--ds-green-100)',
      200: 'var(--ds-green-200)',
      300: 'var(--ds-green-300)',
      400: 'var(--ds-green-400)',
      500: 'var(--ds-green-500)',
      600: 'var(--ds-green-600)',
      700: 'var(--ds-green-700)',
      800: 'var(--ds-green-800)',
      900: 'var(--ds-green-900)',
      1000: 'var(--ds-green-1000)',
    },
  
    // Purple
    'purple': {
      100: 'var(--ds-purple-100)',
      200: 'var(--ds-purple-200)',
      300: 'var(--ds-purple-300)',
      400: 'var(--ds-purple-400)',
      500: 'var(--ds-purple-500)',
      600: 'var(--ds-purple-600)',
      700: 'var(--ds-purple-700)',
      800: 'var(--ds-purple-800)',
      900: 'var(--ds-purple-900)',
      1000: 'var(--ds-purple-1000)',
    },
  
    // Pink 
    'pink': {
      100: 'var(--ds-pink-100)',
      200: 'var(--ds-pink-200)',
      300: 'var(--ds-pink-300)',
      400: 'var(--ds-pink-400)',
      500: 'var(--ds-pink-500)',
      600: 'var(--ds-pink-600)',
      700: 'var(--ds-pink-700)',
      800: 'var(--ds-pink-800)',
      900: 'var(--ds-pink-900)',
      1000: 'var(--ds-pink-1000)',
    },
  
    // Teal
    'teal': {
      100: 'var(--ds-teal-100)',
      200: 'var(--ds-teal-200)',
      300: 'var(--ds-teal-300)',
      400: 'var(--ds-teal-400)',
      500: 'var(--ds-teal-500)',
      600: 'var(--ds-teal-600)',
      700: 'var(--ds-teal-700)',
      800: 'var(--ds-teal-800)',
      900: 'var(--ds-teal-900)',
      1000: 'var(--ds-teal-1000)',
    }
  };
  
  module.exports = colors;
=== ./middleware.ts ===

import { clerkMiddleware } from "@clerk/nextjs/server";

export default clerkMiddleware();

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
};
=== ./app/checkout/page.tsx ===

import Link from "next/link"
import { currentUser } from '@clerk/nextjs/server'
import { retrieveStripeCheckoutSession } from "@/lib/actions/stripe-actions" 

interface CheckoutPageProps {
  searchParams: {
    sessionId?: string
  }
}

export default async function CheckoutPage({ searchParams }: CheckoutPageProps) {
  const sessionId = searchParams.sessionId

  // If we have a sessionId, attempt to retrieve the session and update user data
  if (sessionId) {
    await retrieveStripeCheckoutSession(sessionId)
  }

  const user = await currentUser()
  const credits = user?.publicMetadata?.credits as number | undefined

  return (
    <section className="py-24 min-h-[60vh] flex flex-col items-center justify-center text-center px-4">
      <div className="max-w-md w-full bg-white dark:bg-zinc-950 border border-zinc-100 dark:border-zinc-800 rounded-xl p-8 shadow-sm">
        <h1 className="text-3xl font-semibold mb-6 bg-gradient-to-r from-blue-600 to-violet-600 bg-clip-text text-transparent">
          Thank You!
        </h1>
        <p className="text-zinc-600 dark:text-zinc-400 mb-6">
          Your payment has been successfully processed and your credits have been added to your account.
        </p>
        {typeof credits === "number" && (
          <div className="bg-blue-50 dark:bg-blue-950/50 rounded-lg p-4 mb-8">
            <p className="text-lg font-medium text-blue-700 dark:text-blue-300">
              Current Balance: {credits.toLocaleString()} credits
            </p>
          </div>
        )}
        <Link
          href="/"
          className="inline-flex items-center justify-center rounded-lg px-6 py-3 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:ring-offset-2 dark:focus:ring-offset-zinc-950 w-full"
        >
          Return to Dashboard
        </Link>
      </div>
    </section>
  )
}

=== ./app/dashboard/page.tsx ===

import { z } from "zod";
import FactChecker from "@/components/dashboard/fact-checker";
import { getSubmissionById } from "@/src/index";

export default async function DashboardPage({
  searchParams,
}: {
  searchParams: { id?: string };
}) {
  const searchParamsSchema = z.object({
    id: z.string().optional(),
  });
  const parseResult = searchParamsSchema.safeParse(searchParams);

  if (!parseResult.success) {
    return (
      <div>
        <h1>No Submission ID Provided</h1>
        <p>Please submit your text first.</p>
      </div>
    );
  }

  const { id } = parseResult.data;
  
  if (!id) {
    return (
      <div>
        <h1>No Submission ID Provided</h1>
        <p>Please submit your text first.</p>
      </div>
    );
  }

  const submission = await getSubmissionById(id);

  if (!submission) {
    return (
      <div>
        <h1>Submission Not Found</h1>
        <p>The submission with the provided ID does not exist.</p>
      </div>
    );
  }

  if (typeof submission.content !== 'string') {
    return (
      <div>
        <h1>Invalid Submission Data</h1>
        <p>The submission data is incomplete or malformed.</p>
      </div>
    );
  }

  return (
    <div className="flex h-[100dvh] flex-col items-center overflow-hidden">
      <FactChecker
        submissionId={id}
        text={submission.content}
      />
    </div>
  );
}

=== ./app/layout.tsx ===

import type { Metadata } from "next";
import { GeistSans } from "geist/font/sans";
import "./globals.css";
import { Analytics } from "@vercel/analytics/next";
import {
  ClerkProvider,
} from "@clerk/nextjs";
import NavBar from "@/components/NavBar";
import { Toaster } from "@/components/ui/toaster";

export const metadata: Metadata = {
  title: "Hallucinations Detector Tool",
  description: "Detect Hallucinations in Your Content Instantly for Free.",
  metadataBase: new URL("https://demo.exa.ai/hallucination-detector"),

  // Favicon
  icons: {
    icon: "/favicon1.ico",
    shortcut: "/favicon1.ico",
    apple: "/favicon1.ico",
  },

  // Open Graph
  openGraph: {
    title: "Hallucinations Detector Tool",
    description: "Detect Hallucinations in Your Content Instantly for Free.",
    url: "https://demo.exa.ai/hallucination-detector",
    siteName: "Hallucinations Detector Tool",
    images: [
      {
        url: "/opengraph-image.png",
        width: 1200,
        height: 630,
        alt: "Hallucinations Detector Tool",
      },
    ],
    locale: "en_US",
    type: "website",
  },

  // Twitter
  twitter: {
    card: "summary_large_image",
    title: "Hallucinations Detector Tool",
    description: "Detect Hallucinations in Your Content Instantly for Free.",
    images: ["https://demo.exa.ai/hallucination-detector/opengraph-image.jpg"],
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider>
      <html lang="en" className="bg-gradient-to-b from-[#FDFBF9] to-[#F9F7F5]">
        <body className={GeistSans.className}>
          <NavBar />
          <main>
            {children}
          </main>
          <Toaster />
          <Analytics />
        </body>
      </html>
    </ClerkProvider>
  );
}

=== ./app/api/stripe-webhook/route.ts ===

import { NextResponse } from 'next/server';
import { clerkClient } from '@clerk/nextjs/server';
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-11-20.acacia',
});

// Map your Price IDs to the number of credits to add
const priceToCreditsMap: Record<string, number> = {
  "price_1QWPITPvVlQ90xYWcl4Jf0z5": 20000,
};

export async function POST(req: Request) {
  const payload = await req.text();
  const signature = req.headers.get('stripe-signature') as string;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(payload, signature, process.env.STRIPE_WEBHOOK_SECRET!);
  } catch (err) {
    console.error('Webhook signature verification failed.', err);
    return NextResponse.json(
      { error: 'Webhook signature verification failed.' },
      { status: 400 }
    );
  }

  switch (event.type) {
    case 'checkout.session.completed': {
      const session = event.data.object as Stripe.Checkout.Session;
      
      if (!session.metadata?.userId) {
        return NextResponse.json({ received: true });
      }

      console.log('session', session.metadata.userId);

      try {
        await clerkClient().then(client => 
          client.users.updateUserMetadata(session.metadata!.userId, {
            publicMetadata: {
              stripeCustomerId: session.customer?.toString(),
              credits: 20000
            }
          })
        );

        console.log(`Payment successful for session ID: ${session.id}`);
        return NextResponse.json({ received: true });
      } catch (error) {
        console.error('Failed to update user metadata:', error);
        return NextResponse.json(
          { received: true, error: 'Failed to update user metadata' },
          { status: 500 }
        );
      }
    }

    default:
      console.log(`Unhandled event type: ${event.type}`);
      return NextResponse.json({ received: true });
  }
}

=== ./app/api/submit/route.ts ===

import { NextResponse } from 'next/server';
import { saveSubmission } from '@/src/index';

export async function POST(request: Request) {
  try {
    const { content } = await request.json();

    if (!content?.trim() || content.trim().length < 50) {
      return NextResponse.json({ error: 'Content too short.' }, { status: 400 });
    }

    const submission = await saveSubmission({ content });
    return NextResponse.json({ id: submission.id });

  } catch (error) {
    console.error('Error:', error);
    return NextResponse.json({ error: 'Submission failed.' }, { status: 500 });
  }
}
=== ./app/api/plans/route.ts ===

import { NextResponse } from 'next/server';
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export async function GET() {
  try {
    const prices = await stripe.prices.list({
      expand: ['data.product'],
      active: true,
      type: 'recurring',
    });

    const plans = prices.data.map(price => ({
      id: price.id,
      name: (price.product as Stripe.Product).name,
      description: (price.product as Stripe.Product).description,
      price: price.unit_amount,
      interval: price.recurring?.interval,
      price_id: price.id,
    }));

    return NextResponse.json(plans);
  } catch (error) {
    console.error(error);
    return NextResponse.json({ error: 'Error fetching subscription plans' }, { status: 500 });
  }
}
=== ./app/api/extractclaims/route.ts ===

import { NextRequest, NextResponse } from "next/server";
import { openai } from "@ai-sdk/openai";
import { generateObject } from "ai";
import {
  LLMExtractedClaimSchema
} from "@/lib/schemas";

export const maxDuration = 60;

export async function POST(req: NextRequest) {
  try {
    const json = await req.json();
    const { text } = json;

    const llmClaims = await generateObject({
      model: openai("gpt-4o-mini"),
      output: 'array',
      schema: LLMExtractedClaimSchema,
      prompt: `You are an expert at extracting claims from text and crafting precise search queries.
      Your task is to identify and list all claims present, true or false, in the given text. Each claim should be a single, verifiable statement.
      If the input content is very lengthy, then pick the major claims.

      IMPORTANT: Each claim MUST be a continuous, uninterrupted sequence of text from the original content. You cannot combine separate parts or skip over text - the claim must appear exactly as-is in one continuous segment of the original text.

      For each claim, also provide:
      1. The original part of the sentence from which the claim is derived
      2. A search query formatted as a specific, detailed question that would help verify the claim. The question should:
         - Include all relevant context from the claim (dates, numbers, names, etc.)
         - Be specific enough to get accurate results
         - Focus on the core assertion being made
         - Use natural language as a question
         Example questions:
         - For "Tesla sold 500,000 cars in 2020":
           "How many vehicles did Tesla sell globally in 2020?"
         - For "COVID-19 vaccine reduces transmission by 85%":
           "What percentage does the COVID-19 vaccine reduce virus transmission according to scientific studies?"
         - For "Amazon rainforest lost 10,000 acres in 2022":
           "How many acres of Amazon rainforest were lost to deforestation in 2022?"

      Present the claims as a JSON array of objects. Each object should have three keys:
      - "claim": the extracted claim in a single verifiable statement. It should include all the information necessary in order to understand the claim and verify the statement in isolation, without any additional context.
      - "exactText": the portion of the original text that supports or contains the claim. This MUST be a continuous, unbroken sequence of text that appears exactly as-is in the original content.
      - "searchQuery": a specific question that would help verify the claim when searched
      
      Do not include any additional text or commentary in 'exactText'
      Do not combine separate parts of text - each 'exactText' must be continuous and uninterrupted.

      Here is the content: ${text}

      Return the output strictly as a JSON array of objects following this schema:
      [
        {
          "claim": "extracted claim here",
          "exactText": "original text portion here",
          "searchQuery": "specific question to verify the claim?"
        },
        ...
      ]

      Output the result as valid JSON, strictly adhering to the defined schema. Ensure there are no markdown codes or additional elements included in the output. Do not add anything else. Return only JSON.
      Remember: Each exactText MUST be a continuous sequence of text from the original - no gaps, no combining separate parts.
      `
    });

    // Now find start/end indices and add IDs
    const claimsWithIndices = llmClaims.object.map((c, index) => {
      // Use lastIndexOf to find the last occurrence in case text appears multiple times
      const start = text.lastIndexOf(c.exactText); 
      if (start === -1) {
        console.error(`Claim "${c.exactText}" not found in the provided text.`);
        return null;
      }
      const end = start + c.exactText.length;

      return {
        id: index + 1,
        exactText: c.exactText,
        claim: c.claim,
        start,
        end,
        status: 'not yet verified' as const,
        confidence: null,
        explanation: null,
        sources: [],
        searchQuery: c.searchQuery
      };
    }).filter((claim): claim is NonNullable<typeof claim> => claim !== null);

    // Validate that each claim has a searchQuery
    const missingSearchQueries = claimsWithIndices.filter(claim => !claim.searchQuery);
    if (missingSearchQueries.length > 0) {
      throw new Error("All claims must have a searchQuery. Missing searchQuery for claims: " + 
        missingSearchQueries.map(c => `"${c.claim}"`).join(", "));
    } //TODO: remove this once we have search queries

    return NextResponse.json({ claims: claimsWithIndices.slice(0, 5) });
  } catch (error) {
    console.error("Error in extractclaims API:", error);
    const errorMessage = 
      error instanceof Error 
        ? error.message
        : "Unknown error occurred while extracting claims";
    return NextResponse.json(
      { error: `Failed to extract claims | ${errorMessage}` },
      { status: 500 }
    );
  }
}

=== ./app/api/searchandverify/route.ts ===

// app/api/searchandverify/route.ts
import { NextRequest, NextResponse } from "next/server";
import { openai } from "@ai-sdk/openai";
import { generateObject } from "ai";
import { z } from "zod";
import Exa from "exa-js";

import {
  SearchAndVerifyRequestSchema,
  SearchAndVerifyResponseSchema,
  type Claim,
  ExaSourceSchema,
  MergedSourceSchema,
  LLMVerificationResultSchema,
} from "@/lib/schemas";

const exa = new Exa(process.env.EXA_API_KEY as string);

// Helper function to handle Zod errors consistently
function handleZodError(schema: string, data: unknown, err: z.ZodError): never {
  const errorDetails = err.errors.map(e => {
    const path = e.path.join('.');
    const value = path ? `Value at ${path}: ${JSON.stringify(e.path.reduce((obj: any, key) => obj?.[key], data))}` : 'undefined';
    return `${value} - ${e.message}`;
  }).join('\n');

  throw new Error(
    `Invalid ${schema} format:\n` +
    `Input: ${JSON.stringify(data, null, 2)}\n` +
    `Validation errors:\n${errorDetails}`
  );
}

async function searchExaForClaim(
  searchQuery: string
): Promise<z.infer<typeof ExaSourceSchema>[]> {
  const results = await exa.searchAndContents(searchQuery, {
    type: "auto",
    numResults: 3,
    livecrawl: "always",
    text: true,
  });

  const sources = results.results.map((item: any, index: number) => {
    const sourceText = (item.text || "").slice(0, 300); // limit to 300 chars
    return {
      url: item.url,
      title: item.title,
      sourceNumber: index + 1,
      sourceText,
    };
  });

  sources.forEach((src: unknown) => {
    try {
      ExaSourceSchema.parse(src);
    } catch (err) {
      if (err instanceof z.ZodError) {
        handleZodError('ExaSource', src, err);
      }
      throw err;
    }
  });

  return sources;
}

async function verifyClaimWithLLM(
  claimText: string,
  searchQuery: string,
  sources: z.infer<typeof ExaSourceSchema>[]
) {
  const sourcesJson = JSON.stringify(sources, null, 2);

  const { object } = await generateObject({
    model: openai("gpt-4o-mini"),
    schema: LLMVerificationResultSchema,
    prompt: `You are an expert fact-checker. Given a claim and its sources, verify the claim comprehensively.

Instructions:
- Read the claim and search query carefully to understand the full context.
- Analyze the provided sources, determining how each relates to the claim.
- status: Choose one of "supported", "contradicted", "debated", or "insufficient information".
- confidence: Provide a numeric 0-100 confidence score in your conclusion.
- explanation: A detailed, clear explanation. Include references like {{1}}, {{2}} at the end of sentences that rely on the corresponding sources. Make sure every reference number corresponds to a sourceNumber in citedSources.
- If status is "contradicted", provide a suggestedFix with a corrected version of the claim.
- For citedSources: Each sourceNumber must match exactly those cited in explanation. supports = true/false based on if it directly supports the claim. agreementPercentage and pertinence show how strongly it supports or relates to the claim.

Now apply this logic to the following input.

Claim:
${claimText}

Search Query Used:
${searchQuery}

Sources:
${sourcesJson}`,
  });

  try {
    const verification = LLMVerificationResultSchema.parse(object);
    return verification;
  } catch (err) {
    if (err instanceof z.ZodError) {
      handleZodError('LLMVerificationResult', object, err);
    }
    throw err;
  }
}

function buildFinalClaim(
  id: number,
  exactText: string,
  claimText: string,
  start: number,
  end: number,
  verification: z.infer<typeof LLMVerificationResultSchema>,
  exaSources: z.infer<typeof ExaSourceSchema>[],
  searchQuery: string
): Claim {
  // Merge cited sources with exa sources
  const mergedSources = verification.citedSources.map((cited) => {
    const exaSource = exaSources.find(
      (e) => e.sourceNumber === cited.sourceNumber
    );
    // If no matching exaSource, create fallback
    const base = exaSource
      ? { ...exaSource }
      : {
          url: "https://example.com",
          title: undefined,
          sourceNumber: cited.sourceNumber,
          sourceText: "",
        };

    try {
      return MergedSourceSchema.parse({
        ...base,
        ...cited,
      });
    } catch (err) {
      if (err instanceof z.ZodError) {
        handleZodError('MergedSource', { ...base, ...cited }, err);
      }
      throw err;
    }
  });

  return {
    id,
    exactText,
    claim: claimText,
    start,
    end,
    status: verification.status,
    confidence: verification.confidence,
    explanation: verification.explanation,
    suggestedFix: verification.suggestedFix,
    sources: mergedSources,
    searchQuery: searchQuery,
  };
}

export async function POST(req: NextRequest) {
  try {
    const json = await req.json();
    let parsedRequest;
    try {
      parsedRequest = SearchAndVerifyRequestSchema.parse(json);
    } catch (err) {
      if (err instanceof z.ZodError) {
        handleZodError('SearchAndVerifyRequest', json, err);
      }
      throw err;
    }

    const { claims } = parsedRequest;

    // claims have id, exactText, claim, start, end, searchQuery
    // status='not yet verified', confidence/explanation/sources not set yet
    // We'll do search + verify for each claim in parallel
    const finalClaimsPromises = claims.map(async (c) => {
      const exaSources = await searchExaForClaim(c.searchQuery);
      const verification = await verifyClaimWithLLM(c.claim, c.searchQuery, exaSources);
      const finalClaim = buildFinalClaim(
        c.id,
        c.exactText,
        c.claim,
        c.start,
        c.end,
        verification,
        exaSources,
        c.searchQuery
      );
      return finalClaim;
    });

    const finalClaims = await Promise.all(finalClaimsPromises);

    const response = { claims: finalClaims };
    try {
      const parsed = SearchAndVerifyResponseSchema.parse(response);
      return NextResponse.json(parsed);
    } catch (err) {
      if (err instanceof z.ZodError) {
        handleZodError('SearchAndVerifyResponse', response, err);
      }
      throw err;
    }
  } catch (error: any) {
    console.error("Error in /api/searchandverify:", error);
    const message = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      { error: `Search and verify failed: ${message}` },
      { status: 500 }
    );
  }
}

=== ./app/page.tsx ===

import Landing from "@/components/Landing";

export default function Home() {
  return <Landing />;
}


=== ./utils/helpers.ts ===

import { Claim } from '../lib/types'

export const getStatusColor = (status: string) => {
  switch (status) {
    case 'supported':
      return 'bg-emerald-100 text-emerald-800 border-emerald-200'
    case 'debated':
      return 'bg-yellow-100 text-yellow-800 border-yellow-200'
    case 'contradicted':
      return 'bg-red-100 text-red-800 border-red-200'
    default:
      return 'bg-gray-100 text-gray-800 border-gray-200'
  }
}

=== ./.next/types/app/dashboard/page.ts ===

// File: /Users/michaelryaboy/recent-projects/factfilter/app/dashboard/page.tsx
import * as entry from '../../../../app/dashboard/page.js'
import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'

type TEntry = typeof import('../../../../app/dashboard/page.js')

// Check that the entry is a valid entry
checkFields<Diff<{
  default: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
  metadata?: any
  generateMetadata?: Function
  viewport?: any
  generateViewport?: Function
  
}, TEntry, ''>>()

// Check the prop type of the entry function
checkFields<Diff<PageProps, FirstArg<TEntry['default']>, 'default'>>()

// Check the arguments and return type of the generateMetadata function
if ('generateMetadata' in entry) {
  checkFields<Diff<PageProps, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
}

// Check the arguments and return type of the generateViewport function
if ('generateViewport' in entry) {
  checkFields<Diff<PageProps, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: PageParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

type PageParams = any
export interface PageProps {
  params?: any
  searchParams?: any
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: any
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never



function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'

=== ./.next/types/app/page.ts ===

// File: /Users/michaelryaboy/recent-projects/factfilter/app/page.tsx
import * as entry from '../../../app/page.js'
import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'

type TEntry = typeof import('../../../app/page.js')

// Check that the entry is a valid entry
checkFields<Diff<{
  default: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
  metadata?: any
  generateMetadata?: Function
  viewport?: any
  generateViewport?: Function
  
}, TEntry, ''>>()

// Check the prop type of the entry function
checkFields<Diff<PageProps, FirstArg<TEntry['default']>, 'default'>>()

// Check the arguments and return type of the generateMetadata function
if ('generateMetadata' in entry) {
  checkFields<Diff<PageProps, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
}

// Check the arguments and return type of the generateViewport function
if ('generateViewport' in entry) {
  checkFields<Diff<PageProps, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: PageParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

type PageParams = any
export interface PageProps {
  params?: any
  searchParams?: any
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: any
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never



function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'

=== ./.next/types/app/layout.ts ===

// File: /Users/michaelryaboy/recent-projects/factfilter/app/layout.tsx
import * as entry from '../../../app/layout.js'
import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'

type TEntry = typeof import('../../../app/layout.js')

// Check that the entry is a valid entry
checkFields<Diff<{
  default: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
  metadata?: any
  generateMetadata?: Function
  viewport?: any
  generateViewport?: Function
  
}, TEntry, ''>>()

// Check the prop type of the entry function
checkFields<Diff<LayoutProps, FirstArg<TEntry['default']>, 'default'>>()

// Check the arguments and return type of the generateMetadata function
if ('generateMetadata' in entry) {
  checkFields<Diff<LayoutProps, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()
}

// Check the arguments and return type of the generateViewport function
if ('generateViewport' in entry) {
  checkFields<Diff<LayoutProps, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: PageParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

type PageParams = any
export interface PageProps {
  params?: any
  searchParams?: any
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: any
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never



function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'

=== ./.next/types/app/api/submit/route.ts ===

// File: /Users/michaelryaboy/recent-projects/factfilter/app/api/submit/route.ts
import * as entry from '../../../../../app/api/submit/route.js'
import type { NextRequest } from 'next/server.js'

type TEntry = typeof import('../../../../../app/api/submit/route.js')

// Check that the entry is a valid entry
checkFields<Diff<{
  GET?: Function
  HEAD?: Function
  OPTIONS?: Function
  POST?: Function
  PUT?: Function
  DELETE?: Function
  PATCH?: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
}, TEntry, ''>>()

// Check the prop type of the entry function
if ('GET' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'GET'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'GET'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'GET',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'GET',
        __return_type__: ReturnType<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
}
// Check the prop type of the entry function
if ('HEAD' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'HEAD'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'HEAD'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'HEAD',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'HEAD',
        __return_type__: ReturnType<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
}
// Check the prop type of the entry function
if ('OPTIONS' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'OPTIONS',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'OPTIONS',
        __return_type__: ReturnType<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
}
// Check the prop type of the entry function
if ('POST' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'POST'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'POST'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'POST',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'POST',
        __return_type__: ReturnType<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
}
// Check the prop type of the entry function
if ('PUT' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PUT'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'PUT'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PUT',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PUT',
        __return_type__: ReturnType<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
}
// Check the prop type of the entry function
if ('DELETE' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'DELETE'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'DELETE'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'DELETE',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'DELETE',
        __return_type__: ReturnType<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
}
// Check the prop type of the entry function
if ('PATCH' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PATCH'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'PATCH'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PATCH',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PATCH',
        __return_type__: ReturnType<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: PageParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

type PageParams = any
export interface PageProps {
  params?: any
  searchParams?: any
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: any
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never

type ParamCheck<T> = {
  __tag__: string
  __param_position__: string
  __param_type__: T
}

function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'

=== ./.next/types/app/api/extractclaims/route.ts ===

// File: /Users/michaelryaboy/recent-projects/factfilter/app/api/extractclaims/route.ts
import * as entry from '../../../../../app/api/extractclaims/route.js'
import type { NextRequest } from 'next/server.js'

type TEntry = typeof import('../../../../../app/api/extractclaims/route.js')

// Check that the entry is a valid entry
checkFields<Diff<{
  GET?: Function
  HEAD?: Function
  OPTIONS?: Function
  POST?: Function
  PUT?: Function
  DELETE?: Function
  PATCH?: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
}, TEntry, ''>>()

// Check the prop type of the entry function
if ('GET' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'GET'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'GET'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'GET',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'GET',
        __return_type__: ReturnType<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
}
// Check the prop type of the entry function
if ('HEAD' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'HEAD'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'HEAD'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'HEAD',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'HEAD',
        __return_type__: ReturnType<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
}
// Check the prop type of the entry function
if ('OPTIONS' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'OPTIONS',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'OPTIONS',
        __return_type__: ReturnType<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
}
// Check the prop type of the entry function
if ('POST' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'POST'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'POST'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'POST',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'POST',
        __return_type__: ReturnType<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
}
// Check the prop type of the entry function
if ('PUT' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PUT'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'PUT'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PUT',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PUT',
        __return_type__: ReturnType<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
}
// Check the prop type of the entry function
if ('DELETE' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'DELETE'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'DELETE'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'DELETE',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'DELETE',
        __return_type__: ReturnType<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
}
// Check the prop type of the entry function
if ('PATCH' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PATCH'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'PATCH'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PATCH',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PATCH',
        __return_type__: ReturnType<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: PageParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

type PageParams = any
export interface PageProps {
  params?: any
  searchParams?: any
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: any
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never

type ParamCheck<T> = {
  __tag__: string
  __param_position__: string
  __param_type__: T
}

function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'

=== ./.next/types/app/api/searchandverify/route.ts ===

// File: /Users/michaelryaboy/recent-projects/factfilter/app/api/searchandverify/route.ts
import * as entry from '../../../../../app/api/searchandverify/route.js'
import type { NextRequest } from 'next/server.js'

type TEntry = typeof import('../../../../../app/api/searchandverify/route.js')

// Check that the entry is a valid entry
checkFields<Diff<{
  GET?: Function
  HEAD?: Function
  OPTIONS?: Function
  POST?: Function
  PUT?: Function
  DELETE?: Function
  PATCH?: Function
  config?: {}
  generateStaticParams?: Function
  revalidate?: RevalidateRange<TEntry> | false
  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'
  dynamicParams?: boolean
  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'
  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]
  runtime?: 'nodejs' | 'experimental-edge' | 'edge'
  maxDuration?: number
  
}, TEntry, ''>>()

// Check the prop type of the entry function
if ('GET' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'GET'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'GET'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'GET',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'GET',
        __return_type__: ReturnType<MaybeField<TEntry, 'GET'>>
      },
      'GET'
    >
  >()
}
// Check the prop type of the entry function
if ('HEAD' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'HEAD'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'HEAD'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'HEAD',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'HEAD',
        __return_type__: ReturnType<MaybeField<TEntry, 'HEAD'>>
      },
      'HEAD'
    >
  >()
}
// Check the prop type of the entry function
if ('OPTIONS' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'OPTIONS'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'OPTIONS',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'OPTIONS',
        __return_type__: ReturnType<MaybeField<TEntry, 'OPTIONS'>>
      },
      'OPTIONS'
    >
  >()
}
// Check the prop type of the entry function
if ('POST' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'POST'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'POST'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'POST',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'POST',
        __return_type__: ReturnType<MaybeField<TEntry, 'POST'>>
      },
      'POST'
    >
  >()
}
// Check the prop type of the entry function
if ('PUT' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PUT'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'PUT'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PUT',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PUT',
        __return_type__: ReturnType<MaybeField<TEntry, 'PUT'>>
      },
      'PUT'
    >
  >()
}
// Check the prop type of the entry function
if ('DELETE' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'DELETE'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'DELETE'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'DELETE',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'DELETE',
        __return_type__: ReturnType<MaybeField<TEntry, 'DELETE'>>
      },
      'DELETE'
    >
  >()
}
// Check the prop type of the entry function
if ('PATCH' in entry) {
  checkFields<
    Diff<
      ParamCheck<Request | NextRequest>,
      {
        __tag__: 'PATCH'
        __param_position__: 'first'
        __param_type__: FirstArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  checkFields<
    Diff<
      ParamCheck<PageParams>,
      {
        __tag__: 'PATCH'
        __param_position__: 'second'
        __param_type__: SecondArg<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
  
  checkFields<
    Diff<
      {
        __tag__: 'PATCH',
        __return_type__: Response | void | never | Promise<Response | void | never>
      },
      {
        __tag__: 'PATCH',
        __return_type__: ReturnType<MaybeField<TEntry, 'PATCH'>>
      },
      'PATCH'
    >
  >()
}

// Check the arguments and return type of the generateStaticParams function
if ('generateStaticParams' in entry) {
  checkFields<Diff<{ params: PageParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()
  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()
}

type PageParams = any
export interface PageProps {
  params?: any
  searchParams?: any
}
export interface LayoutProps {
  children?: React.ReactNode

  params?: any
}

// =============
// Utility types
type RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never

// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>

type FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never
type SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never
type MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never

type ParamCheck<T> = {
  __tag__: string
  __param_position__: string
  __param_type__: T
}

function checkFields<_ extends { [k in keyof any]: never }>() {}

// https://github.com/sindresorhus/type-fest
type Numeric = number | bigint
type Zero = 0 | 0n
type Negative<T extends Numeric> = T extends Zero ? never : `${T}` extends `-${string}` ? T : never
type NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'

=== ./next-env.d.ts ===

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

=== ./tailwind.config.ts ===

import type { Config } from "tailwindcss";
const colors = require('tailwindcss/colors')


const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
			blue: colors.blue,
			neutral: colors.neutral,
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			},
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
		animation: {
  			'fade-up': 'fade-up 0.5s ease-out forwards'
  		},
  		keyframes: {
  			'fade-up': {
  				'0%': {
  					opacity: '0',
  					transform: 'translateY(20px)'
  				},
  				'100%': {
  					opacity: '1',
  					transform: 'translateY(0)'
  				}
  			}
  		},
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

=== ./components/ui/tabs.tsx ===

"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

=== ./components/ui/card.tsx ===

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

=== ./components/ui/progress.tsx ===

"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

=== ./components/ui/toaster.tsx ===

"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

=== ./components/ui/ShareButtons.tsx ===

"use client";
import { useState } from 'react';
import { Twitter, Linkedin, Users } from 'lucide-react';

export default function ShareButtons() {
    const [copyMessage, setCopyMessage] = useState('');
    const toolUrl = 'https://demo.exa.ai/hallucination-detector';
    const shareText = `Just saw this AI tool which can detect hallucinations in your content, seems cool \n\n${toolUrl}`;

    const shareOnTwitter = () => {
        const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}`;
        window.open(twitterUrl, '_blank');
    };

    const shareOnLinkedIn = () => {
        const linkedinUrl = `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(toolUrl)}`;
        window.open(linkedinUrl, '_blank');
    };

    const copyToClipboard = async () => {
        try {
            await navigator.clipboard.writeText(toolUrl);
            setCopyMessage('Copied! Now share the link with your team ');
            setTimeout(() => setCopyMessage(''), 3000);
        } catch (err) {
            setCopyMessage('Failed to copy');
        }
    };

    return (
        <div className="my-12 pt-12 space-y-6 opacity-0 animate-fade-up">
            <h3 className="text-lg text-center text-black mb-6">
                Share this hallucinations detector tool now!
            </h3>
            <div className="flex flex-col sm:flex-row justify-center gap-8">
                <button
                    onClick={shareOnTwitter}
                    className="flex items-center justify-center gap-2 px-6 py-3 bg-[#1DA1F2] text-white rounded-none hover:bg-[#1a8cd8] transition-colors duration-200"
                >
                    <Twitter size={20} />
                    <span>Share on Twitter</span>
                </button>

                <button
                    onClick={shareOnLinkedIn}
                    className="flex items-center justify-center gap-2 px-6 py-3 bg-[#0A66C2] text-white rounded-none hover:bg-[#094d92] transition-colors duration-200"
                >
                    <Linkedin size={20} />
                    <span>Share on LinkedIn</span>
                </button>

                <button
                    onClick={copyToClipboard}
                    className="flex items-center justify-center gap-2 px-6 py-3 bg-gray-800 text-white rounded-none hover:bg-gray-700 transition-colors duration-200"
                >
                    <Users size={20} />
                    <span>Share with Your Team</span>
                </button>
            </div>
            {copyMessage && (
                <div className="text-center text-green-600 font-medium mt-4 animate-fade-up">
                    {copyMessage}
                </div>
            )}
        </div>
    );
}
=== ./components/ui/resizable.tsx ===

"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

=== ./components/ui/label.tsx ===

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

=== ./components/ui/drawer.tsx ===

"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

=== ./components/ui/nice-blue-button.tsx ===

import React from 'react'
import { cn } from '@/lib/utils'

interface NiceBlueButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode
  className?: string
}

export const NiceBlueButton: React.FC<NiceBlueButtonProps> = ({
  children,
  className,
  ...props
}) => {
  return (
    <button
      {...props}
      className={cn(
        "group flex h-10 items-center justify-center rounded-md border border-blue-600 bg-gradient-to-b from-blue-400 via-blue-500 to-blue-600 px-4 text-neutral-50 shadow-[inset_0_1px_0px_0px_#93c5fd] hover:from-blue-600 hover:via-blue-600 hover:to-blue-600 active:[box-shadow:none]",
        className
      )}
    >
      <span className="block group-active:[transform:translate3d(0,1px,0)]">
        {children}
      </span>
    </button>
  )
}
=== ./components/ui/tooltip.tsx ===

"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

=== ./components/ui/LoadingMessages.tsx ===

import { useEffect, useState } from "react";
import { Skeleton } from "./skeleton";

type LoadingMessagesProps = {
  isGenerating: boolean;
};

const loadingMessages = [
  "\u00A0\u00A0Analyzing Your Content...",
  "\u00A0\u00A0Extracting Key Claims...",
  "\u00A0\u00A0Searching for Reliable Sources...",
  "\u00A0\u00A0Verifying Each Claim for Accuracy...",
  "\u00A0\u00A0Generating Your Results...",
  "Almost there...\u00A0\u00A0",
];

const LoadingMessages: React.FC<LoadingMessagesProps> = ({ isGenerating }) => {
  const [currentMessageIndex, setCurrentMessageIndex] = useState(0);

  useEffect(() => {
    let intervalId: NodeJS.Timeout;

    if (isGenerating) {
      setCurrentMessageIndex(0);

      // Set interval to change the message every 1-3 seconds
      intervalId = setInterval(() => {
        setCurrentMessageIndex((prevIndex) => {
          const nextIndex = prevIndex + 1;

          if (nextIndex < loadingMessages.length) {
            return nextIndex;
          } else {
            clearInterval(intervalId);
            return prevIndex;
          }
        });
      }, Math.floor(Math.random() * 9000) + 3000);
    } else {
      setCurrentMessageIndex(0);
    }

    return () => clearInterval(intervalId);
  }, [isGenerating]);

  return (
    <div className="w-full mt-20 mb-40">
      <div className="text-secondary-accent/50 text-lg opacity-0 animate-fade-up [animation-delay:200ms]">
        {isGenerating ? loadingMessages[currentMessageIndex] : ""}
      </div>

      <div className="flex flex-col space-y-3 mt-6">
        <Skeleton className="h-[100px] rounded-none bg-secondary-accent opacity-0 animate-fade-up [animation-delay:400ms]" />
        <div className="space-y-2">
          <Skeleton className="h-4 rounded-none bg-secondary-accent opacity-0 animate-fade-up [animation-delay:500ms]" />
          <Skeleton className="h-4 rounded-none bg-secondary-accent opacity-0 animate-fade-up [animation-delay:600ms]" />
        </div>
      </div>
    </div>
  );
};

export default LoadingMessages;
=== ./components/ui/radio-group.tsx ===

"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }

=== ./components/ui/animated-gradient-text.tsx ===

import { ReactNode } from "react";

import { cn } from "@/lib/utils";

export default function AnimatedGradientText({
  children,
  className,
}: {
  children: ReactNode;
  className?: string;
}) {
  return (
    <div
      className={cn(
        "group relative mx-auto flex max-w-fit flex-row items-center justify-center rounded-2xl bg-white/40 px-4 py-1.5 text-sm font-medium shadow-[inset_0_-8px_10px_#8fdfff1f] backdrop-blur-sm transition-shadow duration-500 ease-out [--bg-size:300%] hover:shadow-[inset_0_-5px_10px_#8fdfff3f] dark:bg-black/40",
        className,
      )}
    >
      <div
        className={`absolute inset-0 block h-full w-full animate-gradient bg-gradient-to-r from-[#254bf1]/50 via-purple-600/50 to-[#254bf1]/50 bg-[length:var(--bg-size)_100%] p-[1px] ![mask-composite:subtract] [border-radius:inherit] [mask:linear-gradient(#fff_0_0)_content-box,linear-gradient(#fff_0_0)]`}
      />

      {children}
    </div>
  );
}
=== ./components/ui/TagPill.tsx ===

import React from 'react';

interface TagPillProps {
  content: string;
  icon?: React.ReactNode;
}

const TagPill = ({ content, icon }: TagPillProps) => {
  return (
    <div className="inline-flex items-center px-3 py-2 rounded-full bg-brand-fainter text-brand-default text-sm break-all">
      <div className="flex items-center min-w-0">
        {icon && <span className="mr-2 flex-shrink-0">{icon}</span>}
        <span className="truncate">{content}</span>
      </div>
    </div>
  );
};

export default TagPill;
=== ./components/ui/dialog.tsx ===

"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

=== ./components/ui/badge.tsx ===

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

=== ./components/ui/button.tsx ===

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

=== ./components/ui/toast.tsx ===

"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

=== ./components/ui/textarea.tsx ===

import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

=== ./components/ui/skeleton.tsx ===

import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }

=== ./components/NavBar.tsx ===

"use client";

import Image from "next/image";
import Link from "next/link";
import useScroll from "@/lib/hooks/use-scroll";
import { SignedIn, SignedOut, SignInButton, UserButton } from "@clerk/nextjs";
import { LayoutDashboard } from "lucide-react";
import UpgradeModal from "@/components/UpgradeModal";

export default function NavBar() {
  const scrolled = useScroll(50);

  return (
    <>
      <div
        className={`fixed top-0 flex w-full justify-center ${
          scrolled
            ? "border-b border-gray-200 bg-white/50 backdrop-blur-xl"
            : "bg-white/0"
        } z-30 transition-all`}
      >
        <div className="mx-5 flex h-16 w-full max-w-screen-xl items-center justify-between">
          <Link href="/" className="flex items-center font-display text-2xl">
            <Image
              src="/logo.png"
              alt="Precedent logo"
              width="30"
              height="30"
              className="mr-1 rounded-sm"
            />
            <p className="font-semibold">FactFilter</p>
          </Link>
          <div className="flex items-center space-x-4">
            <SignedOut>
              <SignInButton mode="modal">
                <button className="rounded-full border border-black bg-black px-4 py-1.5 text-sm text-white transition-colors hover:bg-white hover:text-black">
                  Sign In
                </button>
              </SignInButton>
            </SignedOut>
            <SignedIn>
              {/* The Upgrade Modal button appears only when signed in */}
              <UpgradeModal />
              <UserButton>
                <UserButton.MenuItems>
                  <UserButton.Link
                    label="Dashboard"
                    labelIcon={<LayoutDashboard className="h-4 w-4" />}
                    href="/"
                  />
                </UserButton.MenuItems>
              </UserButton>
            </SignedIn>
          </div>
        </div>
      </div>
    </>
  );
}

=== ./components/PreviewClaimCard.tsx ===

// PreviewClaimCard.tsx
import React from 'react';
import { ChevronRight } from 'lucide-react';

interface Claim {
  claim: string;
  assessment: string;
  summary: string;
  exact_text: string;
  fixed_exact_text: string;
  confidence_score: number;
  url_sources?: string[];
}

interface PreviewClaimCardProps {
  claim: Claim;
  onAcceptFix: (claim: Claim) => void;
}

export const PreviewClaimCard: React.FC<PreviewClaimCardProps> = ({ claim, onAcceptFix }) => {
  const isTrue = claim.assessment.toLowerCase().includes('true');
  const hasFix = claim.fixed_exact_text !== claim.exact_text;

  return (
    <div className="bg-white border rounded-none shadow-sm p-6 space-y-4 opacity-0 animate-fade-up [animation-delay:600ms]">
      <h3 className="font-semibold text-lg text-gray-900">{claim.claim}</h3>

      <div className="flex items-center gap-3">
        <span
          className={`inline-flex items-center px-3 py-1 rounded-none text-sm font-medium ${
            isTrue
              ? 'bg-green-100 text-green-800 border border-green-200'
              : 'bg-red-100 text-red-800 border border-red-200'
          }`}
        >
          <span className="mr-2">{isTrue ? '' : ''}</span>
          {isTrue ? 'Supported' : 'Refuted'}
        </span>
        <span className="text-gray-600 text-sm">
          {claim.confidence_score}% Confident
        </span>
      </div>

      <p className="text-gray-700">{claim.summary}</p>

      <div className="space-y-2 pt-1">
        <div className="flex items-center gap-2 text-gray-700">
          <ChevronRight size={20} />
          <span className="font-medium">Sources</span>
        </div>
        
        <ul className="space-y-2 pl-6">
          {claim.url_sources && claim.url_sources.length > 0 ? (
            claim.url_sources.map((source, idx) => (
              <li key={idx}>
                <a
                  href={source}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-600 hover:text-blue-800 hover:underline text-sm break-all"
                >
                  {source}
                </a>
              </li>
            ))
          ) : (
            <li className="text-gray-500 italic">No sources available</li>
          )}
        </ul>
      </div>

      {hasFix && (
        <div className="pt-5 space-y-2">
            <div className="flex items-center gap-2">
                <span className="font-medium text-gray-700">Suggested Fix</span>
            </div>
                <div className="space-y-2 pb-2">
                    <p className="text-gray-500 line-through">{claim.exact_text}</p>
                    <p className="text-green-700">{claim.fixed_exact_text}</p>
                </div>
                <button
                    onClick={() => onAcceptFix(claim)}
                    className="w-full mt-4 px-4 py-2 bg-brand-default text-white font-semibold rounded-none hover:ring-1 transition-colors"
                    >
                    Accept Fix
                </button>
        </div>
        )}

    </div>
  );
};
=== ./components/PreviewBox.tsx ===

'use client'

import React, { useState, useEffect, useMemo } from 'react'
import { PreviewClaimCard } from './PreviewClaimCard'
import { Copy, CheckCheck, AlertTriangle, CheckCircle2 } from 'lucide-react'
import { Button } from "@/components/ui/button"
import { Card } from "@/components/ui/card"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { Badge } from "@/components/ui/badge"

interface Claim {
  claim: string
  assessment: string
  summary: string
  exact_text: string
  fixed_exact_text: string
  confidence_score: number
  url_sources?: string[]
}

interface PreviewBoxProps {
  content: string
  claims: Claim[]
}

const PreviewBox: React.FC<PreviewBoxProps> = ({ content, claims }) => {
  const [displayText, setDisplayText] = useState(content)
  const [selectedClaim, setSelectedClaim] = useState<Claim | null>(null)
  const [copied, setCopied] = useState(false)

  const filteredClaims = useMemo(() => claims.filter(
    (claim) => claim.assessment.toLowerCase() !== 'insufficient information'
  ), [claims])

  const claimsNeedingFix = useMemo(() => filteredClaims.filter(
    (claim) => claim.assessment.toLowerCase() === 'false'
  ), [filteredClaims])

  const falseClaimsCount = claimsNeedingFix.length
  const trueClaimsCount = filteredClaims.length - falseClaimsCount

  useEffect(() => {
    if (claimsNeedingFix.length > 0 && !selectedClaim) {
      setSelectedClaim(claimsNeedingFix[0])
    }
  }, [claimsNeedingFix, selectedClaim])

  const highlightClaims = useMemo(() => {
    let segments = []
    let lastIndex = 0

    const sortedClaims = [...filteredClaims].sort((a, b) => {
      return displayText.indexOf(a.exact_text) - displayText.indexOf(b.exact_text)
    })

    sortedClaims.forEach((claim) => {
      const index = displayText.indexOf(claim.exact_text, lastIndex)
      if (index !== -1) {
        const previousText = displayText.substring(lastIndex, index)
        segments.push(
          previousText.split('\n').map((line, i) => (
            <React.Fragment key={`text-${lastIndex}-${i}`}>
              {i > 0 && <br />}
              {line}
            </React.Fragment>
          ))
        )

        const isTrue = claim.assessment.toLowerCase().includes('true')
        segments.push(
          <TooltipProvider key={`claim-${index}`}>
            <Tooltip>
              <TooltipTrigger asChild>
                <span
                  className={`
                    relative cursor-pointer transition-all duration-200
                    ${isTrue ? 
                      'bg-green-50 hover:bg-green-100 dark:bg-green-950/30 dark:hover:bg-green-950/50' : 
                      'bg-red-50 hover:bg-red-100 dark:bg-red-950/30 dark:hover:bg-red-950/50'
                    }
                    ${selectedClaim === claim ? 
                      isTrue ? 'ring-2 ring-green-500/20' : 'ring-2 ring-red-500/20' 
                      : ''
                    }
                    px-1 py-0.5 rounded-sm
                  `}
                  onClick={() => setSelectedClaim(claim)}
                >
                  {claim.exact_text}
                  <span className={`
                    absolute -top-1 -right-1 w-2 h-2 rounded-full
                    ${isTrue ? 'bg-green-500' : 'bg-red-500'}
                  `} />
                </span>
              </TooltipTrigger>
              <TooltipContent>
                <div className="flex items-center gap-2">
                  {isTrue ? <CheckCircle2 className="w-4 h-4 text-green-500" /> : <AlertTriangle className="w-4 h-4 text-red-500" />}
                  <p>{isTrue ? 'Verified claim' : 'False claim'}</p>
                </div>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )
        lastIndex = index + claim.exact_text.length
      }
    })

    const remainingText = displayText.substring(lastIndex)
    segments.push(
      remainingText.split('\n').map((line, i) => (
        <React.Fragment key={`text-end-${i}`}>
          {i > 0 && <br />}
          {line}
        </React.Fragment>
      ))
    )

    return segments
  }, [displayText, filteredClaims, selectedClaim])

  const acceptFix = (claim: Claim) => {
    setDisplayText(displayText.replace(claim.exact_text, claim.fixed_exact_text))
    
    const currentIndex = claimsNeedingFix.indexOf(claim)
    const nextClaim = claimsNeedingFix[currentIndex + 1]
    setSelectedClaim(nextClaim || null)
  }

  const handleCopy = async () => {
    await navigator.clipboard.writeText(displayText)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <div className="w-full max-w-4xl mx-auto space-y-6">
      <Card className="overflow-hidden border-0 bg-gradient-to-b from-white to-gray-50/50 dark:from-gray-950 dark:to-gray-900/50 shadow-xl">
        <div className="flex items-center justify-between p-4 border-b bg-white/50 dark:bg-gray-950/50">
          <div className="flex items-center gap-3">
            <Badge variant="outline" className="bg-white dark:bg-gray-900">
              {falseClaimsCount} issues found
            </Badge>
            <Badge variant="outline" className="bg-white dark:bg-gray-900">
              {trueClaimsCount} verified claims
            </Badge>
          </div>
          <Button
            onClick={handleCopy}
            variant="ghost"
            size="sm"
            className="text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-100"
          >
            {copied ? (
              <span className="flex items-center gap-2">
                <CheckCheck className="w-4 h-4" />
                Copied
              </span>
            ) : (
              <span className="flex items-center gap-2">
                <Copy className="w-4 h-4" />
                Copy text
              </span>
            )}
          </Button>
        </div>
        
        <div 
          className="p-6 min-h-[200px] text-gray-900 dark:text-gray-100 leading-relaxed"
          aria-live="polite"
        >
          {highlightClaims}
        </div>
      </Card>

      {selectedClaim && (
        <div className="opacity-0 animate-fade-up [animation-delay:200ms] [animation-fill-mode:forwards]">
          <PreviewClaimCard
            claim={selectedClaim}
            onAcceptFix={acceptFix}
          />
        </div>
      )}
    </div>
  )
}

export default PreviewBox

=== ./components/dashboard/ClaimsListResult.tsx ===

import React from 'react';
import { ChevronRight } from 'lucide-react';

interface ClaimsListResult {
  claim: string;
  assessment: string;
  summary: string;
  fixed_exact_text: string;
  confidence_score: number;
  url_sources?: string[];
}

interface ClaimsListResultsProps {
  results: ClaimsListResult[];
}

const ClaimsListResults: React.FC<ClaimsListResultsProps> = ({ results }) => {
  const getStatusBadge = (assessment: string) => {
    const isTrue = assessment.toLowerCase().includes('true');
    return (
      <span 
        className={`inline-flex items-center px-3 py-1 rounded-none text-sm font-medium ${
          isTrue 
            ? 'bg-green-100 text-green-800 border border-green-200' 
            : 'bg-red-100 text-red-800 border border-red-200'
        }`}
      >
        <span className="mr-2">{isTrue ? '' : ''}</span>
        {isTrue ? 'Supported' : 'Refuted'}
      </span>
    );
  };

  return (
    <div className="mt-6 w-full bg-white p-6 border rounded-none shadow-sm space-y-16">
      {results
      .filter((result) => result.assessment.toLowerCase() !== 'insufficient information')
      .map((result, index) => (
        <div key={index} className="space-y-4">
          <h3 className="font-semibold text-lg text-gray-900">{result.claim}</h3>
          
          <div className="flex items-center space-x-3">
            {getStatusBadge(result.assessment)}
            <span className="text-gray-600 text-sm">
              {result.confidence_score}% Confident
            </span>
          </div>
          
          <p className="text-gray-700 mt-2">{result.summary}</p>

          {/* <p className="text-gray-700 mt-2">{result.fixed_exact_text}</p> */}
          
          <div className="mt-4">
            <div className="flex items-center space-x-2 text-gray-700 mb-2">
              <ChevronRight size={20} />
              <span className="font-medium">Sources</span>
            </div>
            
            <ul className="space-y-2 pl-6">
              {result.url_sources && result.url_sources.length > 0 ? (
                result.url_sources.map((source, idx) => (
                  <li key={idx}>
                    <a 
                      href={source}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-blue-600 hover:text-blue-800 hover:underline text-sm break-all"
                    >
                      {source}
                    </a>
                  </li>
                ))
              ) : (
                <li className="text-gray-500 italic">No sources available</li>
              )}
            </ul>
          </div>
        </div>
      ))}
    </div>
  );
};

export default ClaimsListResults;
=== ./components/dashboard/claim-card.tsx ===

// claim-card.tsx

import React from 'react'
import { Card, CardContent } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Check, X, AlertTriangle } from 'lucide-react'
import { type Claim, type MergedSource } from '@/lib/schemas'
import { SourceDetail } from './source-detail'
import { Skeleton } from "@/components/ui/skeleton"
import { cn } from "@/lib/utils"

function getStatusStyles(status: Claim['status']) {
  switch (status) {
    case 'supported':
      return { badgeClasses: 'bg-emerald-100 text-emerald-700 border-emerald-200', icon: <Check className="h-3 w-3 text-emerald-700" /> };
    case 'contradicted':
      return { badgeClasses: 'bg-rose-100 text-rose-700 border-rose-200', icon: <X className="h-3 w-3 text-rose-700" /> };
    case 'debated':
      return { badgeClasses: 'bg-amber-100 text-amber-700 border-amber-200', icon: <AlertTriangle className="h-3 w-3 text-amber-700" /> };
    case 'insufficient information':
      return { badgeClasses: 'bg-gray-100 text-gray-700 border-gray-200', icon: <AlertTriangle className="h-3 w-3 text-gray-700" /> };
    default:
      return { badgeClasses: 'bg-gray-100 text-gray-700 border-gray-200', icon: <AlertTriangle className="h-3 w-3 text-gray-700" /> };
  }
}

interface ClaimCardProps {
  claim: Claim
  isActive: boolean
  isExpanded: boolean
  onClick: () => void
}

const SourceLink: React.FC<{ sourceNumber: number, sources: MergedSource[] }> = ({ 
  sourceNumber, 
  sources 
}) => {
  const source = sources?.find(s => s.sourceNumber === sourceNumber);
  if (!source) return null;

  return (
    <a
      href={source.url}
      target="_blank"
      rel="noopener noreferrer"
      className="inline-flex relative -top-[1px] items-center justify-center rounded-full px-[0.3em] text-[0.60rem] font-mono bg-gray-100 text-gray-700 hover:bg-zinc-200 transition duration-300 min-w-[1rem] h-[1rem] -ml-3"
    >
      {sourceNumber}
    </a>
  );
};


const parseExplanationWithSources = (explanation: string, sources: MergedSource[]) => {
  if (!explanation) return null;
  
  const parts = explanation.split(/(\{\{[0-9]+\}\})/g);
  
  return parts.map((part, index) => {
    const match = part.match(/\{\{([0-9]+)\}\}/);
    if (match) {
      const sourceNumber = parseInt(match[1], 10);
      return (
        <SourceLink 
          key={index} 
          sourceNumber={sourceNumber} 
          sources={sources}
        />
      );
    }
    return <span key={index}>{part}</span>;
  });
};

export const ClaimCard: React.FC<ClaimCardProps> = ({ claim, isActive, isExpanded, onClick }) => {
  const statusStyles = claim?.status ? getStatusStyles(claim.status) : null;

  return (
    <Card
      className={cn(
        "border rounded-md bg-white hover:shadow-md transition-all duration-200 cursor-pointer",
        isActive 
          ? "border-gray-300 ring-2 ring-gray-100 ring-offset-2" 
          : "border-gray-100 hover:border-gray-200"
      )}
      onClick={onClick}
      data-claim-id={claim?.id}
    >
      <CardContent className="p-4">
        {/* Top row: Status and Confidence */}
        <div className="flex items-center space-x-2">
          {!claim?.status ? (
            <Skeleton className="h-3 w-3 rounded-full" />
          ) : (
            <span className={`inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium border ${statusStyles?.badgeClasses}`}>
              {statusStyles?.icon}
              <span className="ml-1">{claim.status.charAt(0).toUpperCase() + claim.status.slice(1)}</span>
            </span>
          )}
          {claim?.confidence !== null && (
            <span className="text-xs text-gray-500">
              {claim.confidence}% Confident
            </span>
          )}
        </div>

        {/* Claim text */}
        {claim?.claim ? (
          <h2 className="text-sm font-medium text-gray-900 mt-2">{claim.claim}</h2>
        ) : (
          <Skeleton className="h-4 w-full mt-2" />
        )}

        {/* Explanation */}
        {claim?.explanation ? (
          <p className="text-sm text-gray-700 mt-2 space-x-1">
            {parseExplanationWithSources(claim.explanation, claim.sources || [])}
          </p>
        ) : (
          <Skeleton className="h-4 w-3/4 mt-2" />
        )}

        {/* Suggested Fix */}
        {claim?.suggestedFix && (
          <section aria-label="Suggested fix" className="mt-2 bg-blue-50 p-3 rounded-md">
            <p className="text-xs font-medium text-blue-700">Suggested Fix:</p>
            <p className="text-xs text-blue-600 mt-0.5">{claim.suggestedFix}</p>
          </section>
        )}

        {/* Sources */}
        {isExpanded && claim?.sources && claim.sources.length > 0 && (
          <div className="mt-4 pt-4 border-t border-gray-200 space-y-4">
            {/* We could add a heading for sources if desired:
            <h3 className="text-xs font-medium text-gray-900">Sources</h3>
            */}
            {claim.sources.map((source: MergedSource, index: number) => (
              <SourceDetail key={index} source={source} />
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  )
}

=== ./components/dashboard/editable-text.tsx ===

import { useEffect, useRef } from 'react'
import { Textarea } from "@/components/ui/textarea"

interface EditableTextProps {
  text: string
  onChange: (text: string) => void
  isEditing: boolean
  className?: string
}

export function EditableText({
  text,
  onChange,
  isEditing,
  className = ""
}: EditableTextProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null)

  useEffect(() => {
    if (isEditing && textareaRef.current) {
      textareaRef.current.focus()
    }
  }, [isEditing])

  if (!isEditing) {
    return (
      <div className={`text-base leading-relaxed text-gray-800 ${className}`}>
        {text}
      </div>
    )
  }

  return (
    <Textarea
      ref={textareaRef}
      value={text}
      onChange={(e) => onChange(e.target.value)}
      className={`min-h-[400px] resize-none font-sans text-base leading-relaxed text-gray-800 placeholder-gray-400 border border-gray-300 rounded-md focus:border-gray-400 focus:ring-0 ${className}`}
      placeholder="Enter your text here..."
    />
  )
}

=== ./components/dashboard/claims-scale.tsx ===

import { Skeleton } from "@/components/ui/skeleton";

interface ClaimsScaleProps {
  claimsCount: number | null;
}

export function ClaimsScale({ claimsCount }: ClaimsScaleProps) {
  return (
    <div className="space-y-4">
      <div className="space-y-2">
        {claimsCount === null ? (
          <Skeleton className="h-7 w-64" />
        ) : (
          <h2 className="text-xl font-semibold text-gray-900">
            {claimsCount} claims found in this document
          </h2>
        )}
        <p className="text-gray-500 text-sm">
          Click on claims to view sources.
        </p>
      </div>
      <div className="flex items-stretch h-2 rounded-full overflow-hidden">
        {/* Updated colors to subtle pastel tones */}
        <div className="bg-emerald-100 flex-1" />
        <div className="bg-amber-100 flex-1" />
        <div className="bg-rose-100 flex-1" />
        <div className="bg-gray-100 flex-1" />
      </div>
      <div className="grid grid-cols-4 gap-4 text-sm">
        <div>
          <h3 className="text-emerald-700 font-semibold">Supported by sources</h3>
        </div>
        <div>
          <h3 className="text-amber-700 font-semibold">
            Debated by sources
          </h3>
        </div>
        <div>
          <h3 className="text-rose-700 font-semibold">
            Contradicted by sources
          </h3>
        </div>
        <div>
          <h3 className="text-gray-700 font-semibold">
            Insufficient information
          </h3>
        </div>
      </div>
    </div>
  );
}


=== ./components/dashboard/fact-checker.tsx ===

"use client";

import React, { useState, useMemo } from "react";
import useSWR from "swr";
import {
  LLMExtractedClaimsResponse as ExtractClaimsResponse,
  type Claim,
  SearchAndVerifyResponse,
} from "@/lib/schemas";

import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
} from "@/components/ui/resizable";
import { ClaimsScale } from "@/components/dashboard/claims-scale";
import { ClaimCard } from "@/components/dashboard/claim-card";
import { SingleClaimView } from "@/components/dashboard/single-claim-view";
import { TextActionBar } from "@/components/dashboard/text-action-bar";
import { EditableText } from "@/components/dashboard/editable-text";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  CheckCircle2,
  AlertTriangle,
  HelpCircle,
  Pencil,
  Copy,
  CheckCheck,
} from "lucide-react";

const MAX_CHARACTERS = 5000;

// Fetchers
async function fetchExtractClaims(
  url: string,
  text: string
): Promise<ExtractClaimsResponse> {
  const resp = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text }),
  });
  if (!resp.ok) throw new Error(`Extraction failed: ${resp.statusText}`);
  return resp.json();
}

async function fetchSearchAndVerify(
  url: string,
  extractedClaims: Claim[]
): Promise<SearchAndVerifyResponse> {
  const resp = await fetch("/api/searchandverify", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      claims: extractedClaims.map((c) => ({
        id: c.id,
        exactText: c.exactText,
        searchQuery: c.searchQuery,
        claim: c.claim,
        start: c.start,
        end: c.end,
      })),
    }),
  });
  if (!resp.ok) throw new Error(`Search and verify failed: ${resp.statusText}`);
  return resp.json();
}

const swrOptions = {
  revalidateOnFocus: false,
  revalidateOnReconnect: false,
  revalidateIfStale: false,
};

interface FactCheckerProps {
  submissionId: string;
  text: string;
}

export default function FactChecker({ submissionId, text }: FactCheckerProps) {
  const [editableText, setEditableText] = useState(text);
  const [activeTab, setActiveTab] = useState<"text" | "analysis">("text");
  const [isEditing, setIsEditing] = useState(false);
  const [activeClaim, setActiveClaim] = useState<Claim | null>(null);
  const [expandedClaimId, setExpandedClaimId] = useState<number | null>(null);
  const [copied, setCopied] = useState(false);

  const [scansLeft, setScansLeft] = useState(5);
  const [totalScans, setTotalScans] = useState(10);

  const hasText = editableText.trim().length > 0;

  // 1. Extract Claims
  const {
    data: extractData,
    error: extractError,
    isLoading: isExtracting,
  } = useSWR(
    hasText ? ["/api/extractclaims", editableText] : null,
    ([url, t]) => fetchExtractClaims(url, t),
    swrOptions
  );
  // Use start and end from extractData
  const extractedClaims: Claim[] | null = useMemo(() => {
    if (!extractData) return null;
    return extractData.claims.map((c, index) => ({
      id: index + 1,
      exactText: c.exactText,
      searchQuery: c.searchQuery, // Add searchQuery field
      claim: c.claim,
      start: c.start,    // use start from extraction
      end: c.end,        // use end from extraction
      status: "not yet verified",
      confidence: null,
      explanation: null,
      sources: [],
    }));
  }, [extractData]);

  // 2. Search and Verify in one step
  const {
    data: searchAndVerifyData,
    error: searchAndVerifyError,
    isLoading: isSearchAndVerifyLoading,
  } = useSWR(
    extractedClaims && extractedClaims.length > 0
      ? ["/api/searchandverify", extractedClaims]
      : null,
    ([url, claims]) => fetchSearchAndVerify(url, claims),
    swrOptions
  );

  const finalClaims: Claim[] | null = useMemo(() => {
    // If searchAndVerifyData is present, use its claims as final
    if (searchAndVerifyData) return searchAndVerifyData.claims;
    // Otherwise fallback to extractedClaims if available
    if (extractedClaims) return extractedClaims;
    return null;
  }, [searchAndVerifyData, extractedClaims]);

  const claims = finalClaims;
  const error =
    extractError?.message || searchAndVerifyError?.message || null;

  const falseClaimsCount = (claims ?? []).filter(
    (c) => c.status === "contradicted"
  ).length;
  const trueClaimsCount = (claims ?? []).filter((c) => c.status === "supported")
    .length;
  const claimsCount = claims ? claims.length : null;

  const isLoadingOverall = isExtracting || isSearchAndVerifyLoading;

  const handleCopy = async () => {
    await navigator.clipboard.writeText(editableText);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleStartEditing = () => {
    setIsEditing(true);
    setActiveClaim(null);
  };

  const handleCancelEditing = () => {
    setIsEditing(false);
    setEditableText(text);
  };

  const handleScan = () => {
    setIsEditing(false);
  };

  const handleUpgrade = () => {
    /* Placeholder */
  };

  const handleBackToText = () => {
    setActiveClaim(null);
    setActiveTab("text");
  };

  const showClaimsSkeleton = isLoadingOverall && !claims;

  const highlightClaims = useMemo(() => {
    if (!claims) return <>{editableText}</>;
    const sortedClaims = [...claims]
      .filter((c) => c.start < c.end)
      .sort((a, b) => a.start - b.start);
    let lastIndex = 0;
    const segments: React.ReactNode[] = [];

    sortedClaims.forEach((claim) => {
      if (
        claim.start >= 0 &&
        claim.end <= editableText.length &&
        claim.start >= lastIndex
      ) {
        const before = editableText.slice(lastIndex, claim.start);
        if (before)
          segments.push(
            <React.Fragment key={`text-${lastIndex}`}>{before}</React.Fragment>
          );

        const unverified = claim.status === "not yet verified";

        const highlightClasses = unverified
          ? "bg-gray-200 hover:bg-gray-300 dark:bg-gray-700/30"
          : claim.status === "supported"
          ? "bg-green-50 hover:bg-green-100 dark:bg-green-950/30"
          : claim.status === "contradicted"
          ? "bg-red-50 hover:bg-red-100 dark:bg-red-950/30"
          : claim.status === "debated"
          ? "bg-blue-50 hover:bg-blue-100 dark:bg-blue-950/30"
          : "bg-yellow-50 hover:bg-yellow-100 dark:bg-yellow-950/30";

        const isActive = activeClaim?.id === claim.id;
        const activeRing = isActive
          ? `ring-1 ${
              unverified
                ? "ring-gray-300"
                : claim.status === "supported"
                ? "ring-green-300"
                : claim.status === "contradicted"
                ? "ring-red-300"
                : claim.status === "debated"
                ? "ring-blue-300"
                : "ring-yellow-300"
            }`
          : "";

        const claimText = editableText.slice(claim.start, claim.end);

        segments.push(
          <TooltipProvider key={`claim-${claim.id}`}>
            <Tooltip>
              <TooltipTrigger asChild>
                <span
                  data-claim-id={claim.id}
                  className={`inline transition-colors duration-200 ease-in-out ${highlightClasses} ${activeRing} rounded-sm px-0.5 py-0.5 cursor-pointer`}
                  onClick={() => {
                    if (activeTab === "text") setActiveTab("analysis");
                    setActiveClaim(claim);
                  }}
                  onKeyDown={(e) => {
                    if (e.key === "Enter" || e.key === " ") {
                      e.preventDefault();
                      if (activeTab === "text") setActiveTab("analysis");
                      setActiveClaim(claim);
                    }
                  }}
                  tabIndex={0}
                  role="button"
                  aria-pressed={isActive}
                >
                  {claimText}
                </span>
              </TooltipTrigger>
              <TooltipContent>
                <div className="flex items-center gap-2">
                  {unverified ? (
                    <AlertTriangle className="w-4 h-4 text-gray-500" />
                  ) : claim.status === "supported" ? (
                    <CheckCircle2 className="w-4 h-4 text-green-500" />
                  ) : claim.status === "contradicted" ? (
                    <AlertTriangle className="w-4 h-4 text-red-500" />
                  ) : claim.status === "debated" ? (
                    <HelpCircle className="w-4 h-4 text-blue-500" />
                  ) : (
                    <HelpCircle className="w-4 h-4 text-yellow-500" />
                  )}
                  <p>
                    {unverified
                      ? "Not verified yet"
                      : claim.status === "supported"
                      ? "Verified claim"
                      : claim.status === "contradicted"
                      ? "False claim"
                      : claim.status === "debated"
                      ? "Debated claim"
                      : "Insufficient info"}
                  </p>
                </div>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        );
        lastIndex = claim.end;
      }
    });

    const remaining = editableText.slice(lastIndex);
    if (remaining)
      segments.push(
        <React.Fragment key={`text-end`}>{remaining}</React.Fragment>
      );

    return segments;
  }, [claims, editableText, activeClaim, activeTab]);

  return (
    <div className="w-full h-full grid grid-rows-[1fr,auto] bg-white border-t border-gray-200 mt-16">
      <div className="overflow-hidden">
        {/* Mobile Tabs */}
        <div className="block lg:hidden w-full">
          <Tabs
            value={activeTab}
            onValueChange={(value) => setActiveTab(value as "text" | "analysis")}
            className="w-full"
          >
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="text">Text</TabsTrigger>
              <TabsTrigger value="analysis">Analysis</TabsTrigger>
            </TabsList>
            <TabsContent
              value="text"
              className="h-[calc(100vh-250px)] overflow-y-auto"
            >
              <div className="p-6 pt-4">
                <div className="flex justify-end mb-4">
                  {!isEditing && (
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleStartEditing}
                      className="gap-2"
                    >
                      <Pencil className="w-4 h-4" />
                      Edit
                    </Button>
                  )}
                </div>
                <div>
                  {isEditing ? (
                    <EditableText
                      text={editableText}
                      onChange={setEditableText}
                      isEditing={true}
                    />
                  ) : (
                    highlightClaims
                  )}
                </div>
              </div>
            </TabsContent>
            <TabsContent
              value="analysis"
              className="h-[calc(100vh-250px)] overflow-y-auto"
            >
              <div className="p-4">
                {activeClaim ? (
                  <SingleClaimView claim={activeClaim} onBack={handleBackToText} />
                ) : (
                  <>
                    <ClaimsScale claimsCount={claimsCount} />
                    <div className="flex justify-between items-center mt-4 mb-2">
                      <h3 className="text-lg font-semibold">Claims</h3>
                    </div>
                    <div className="space-y-3">
                      {error && <div className="text-red-500">{error}</div>}
                      {!claims ? (
                        <>
                          <Skeleton className="h-24 w-full" />
                          <Skeleton className="h-24 w-full" />
                        </>
                      ) : showClaimsSkeleton ? (
                        <>
                          <Skeleton className="h-24 w-full" />
                          <Skeleton className="h-24 w-full" />
                          <Skeleton className="h-24 w-full" />
                        </>
                      ) : (
                        claims.map((claim) => (
                          <ClaimCard
                            key={claim.id}
                            claim={claim}
                            isActive={claim.id === expandedClaimId}
                            isExpanded={claim.id === expandedClaimId}
                            onClick={() =>
                              setExpandedClaimId((prevId) =>
                                prevId === claim.id ? null : claim.id
                              )
                            }
                          />
                        ))
                      )}
                    </div>
                  </>
                )}
              </div>
            </TabsContent>
          </Tabs>
        </div>

        {/* Desktop Split View */}
        <div className="hidden lg:flex w-full h-full">
          <ResizablePanelGroup direction="horizontal" className="w-full">
            <ResizablePanel defaultSize={60} minSize={30}>
              <div className="p-6 pt-4 h-full grid grid-rows-[auto,1fr,auto]">
                <div className="flex justify-end mb-4">
                  {!isEditing && (
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleStartEditing}
                      className="gap-2"
                    >
                      <Pencil className="w-4 h-4" />
                      Edit
                    </Button>
                  )}
                </div>
                <div className="overflow-y-auto">
                  {isEditing ? (
                    <EditableText
                      text={editableText}
                      onChange={setEditableText}
                      isEditing={true}
                    />
                  ) : (
                    highlightClaims
                  )}
                </div>
                {isEditing && (
                  <TextActionBar
                    characterCount={editableText.length}
                    maxCharacters={MAX_CHARACTERS}
                    onCancel={handleCancelEditing}
                    onScan={handleScan}
                    onUpgrade={handleUpgrade}
                  />
                )}
              </div>
            </ResizablePanel>
            <ResizableHandle />
            <ResizablePanel defaultSize={40} minSize={30}>
              <div className="p-4 h-full overflow-y-auto">
                {activeClaim ? (
                  <SingleClaimView claim={activeClaim} onBack={handleBackToText} />
                ) : (
                  <>
                    <ClaimsScale claimsCount={claimsCount} />
                    <div className="flex justify-between items-center mt-4 mb-2">
                      <h3 className="text-lg font-semibold">Claims</h3>
                    </div>
                    <div className="space-y-3">
                      {error && <div className="text-red-500">{error}</div>}
                      {!claims ? (
                        <>
                          <Skeleton className="h-24 w-full" />
                          <Skeleton className="h-24 w-full" />
                        </>
                      ) : showClaimsSkeleton ? (
                        <>
                          <Skeleton className="h-24 w-full" />
                          <Skeleton className="h-24 w-full" />
                          <Skeleton className="h-24 w-full" />
                        </>
                      ) : (
                        claims.map((claim) => (
                          <ClaimCard
                            key={claim.id}
                            claim={claim}
                            isActive={claim.id === expandedClaimId}
                            isExpanded={claim.id === expandedClaimId}
                            onClick={() =>
                              setExpandedClaimId((prevId) =>
                                prevId === claim.id ? null : claim.id
                              )
                            }
                          />
                        ))
                      )}
                    </div>
                  </>
                )}
              </div>
            </ResizablePanel>
          </ResizablePanelGroup>
        </div>
      </div>

      {/* Bottom Bar */}
      <div className="border-t border-gray-100 bg-white">
        <div className="p-2 sm:p-3 flex flex-row items-center justify-between">
          <Button
            variant="outline"
            size="sm"
            onClick={handleCopy}
            className="h-6 sm:h-7 shrink-0"
          >
            {copied ? (
              <span className="flex items-center gap-1.5">
                <CheckCheck className="w-3.5 h-3.5" />
                <span className="hidden sm:inline">Copied</span>
              </span>
            ) : (
              <span className="flex items-center gap-1.5">
                <Copy className="w-3.5 h-3.5" />
                <span className="hidden sm:inline">Copy text</span>
              </span>
            )}
          </Button>
          <div className="flex items-center gap-3 sm:gap-4">
            {isLoadingOverall ? (
              <Skeleton className="h-6 w-16" />
            ) : (
              <Badge variant="secondary" className="h-6 sm:h-7 shrink-0">
                {falseClaimsCount} {falseClaimsCount === 1 ? "issue" : "issues"}
              </Badge>
            )}
            {isLoadingOverall ? (
              <Skeleton className="h-6 w-20" />
            ) : (
              <Badge variant="secondary" className="h-6 sm:h-7 shrink-0">
                {trueClaimsCount} verified
              </Badge>
            )}
            <div className="flex items-center gap-2 sm:gap-3 shrink-0">
              {isLoadingOverall ? (
                <>
                  <Skeleton className="h-4 w-10" />
                  <Skeleton className="h-2 w-24" />
                </>
              ) : (
                <>
                  <span className="text-sm text-gray-600">
                    {scansLeft}/{totalScans}
                  </span>
                  <Progress
                    value={(scansLeft / totalScans) * 100}
                    className="h-2 sm:h-2.5 w-16 sm:w-24"
                  />
                </>
              )}
              <Button
                variant="link"
                size="sm"
                className="text-sm font-medium text-black h-6 sm:h-7 px-2"
              >
                More
              </Button>
            </div>
          </div>
        </div>
      </div>

      {isEditing && activeTab === "text" && (
        <div className="lg:hidden">
          <TextActionBar
            characterCount={editableText.length}
            maxCharacters={MAX_CHARACTERS}
            onCancel={handleCancelEditing}
            onScan={handleScan}
            onUpgrade={handleUpgrade}
          />
        </div>
      )}
    </div>
  );
}

=== ./components/dashboard/text-action-bar.tsx ===

import { ArrowRight } from 'lucide-react'
import { Button } from "@/components/ui/button"
import { Progress } from "@/components/ui/progress"

interface TextActionBarProps {
  characterCount: number
  maxCharacters: number
  onCancel: () => void
  onScan: () => void
  onUpgrade?: () => void
}

export function TextActionBar({
  characterCount,
  maxCharacters,
  onCancel,
  onScan,
  onUpgrade
}: TextActionBarProps) {
  const progress = (characterCount / maxCharacters) * 100
  const isOverLimit = characterCount > maxCharacters

  return (
    <div className="border-t border-gray-100 p-2 flex items-center justify-between gap-4">
      <div className="flex-1 max-w-[200px]">
        <div className="text-sm text-gray-600 mb-1">
          {characterCount.toLocaleString()}/{maxCharacters.toLocaleString()} characters
        </div>
        <Progress 
          value={Math.min(progress, 100)} 
          className="h-1.5"
        >
          <div 
            className={`h-full ${isOverLimit ? 'bg-red-500' : ''}`} 
            style={{ width: `${Math.min(progress, 100)}%` }}
          />
        </Progress>
      </div>
      <div className="flex items-center gap-2">
        <Button
          variant="ghost"
          onClick={onCancel}
        >
          Cancel
        </Button>
        <Button
          onClick={onScan}
          disabled={isOverLimit}
          className="gap-2"
        >
          Scan
          <ArrowRight className="w-4 h-4" />
        </Button>
        {onUpgrade && (
          <Button
            variant="outline"
            onClick={onUpgrade}
            className="hidden sm:inline-flex"
          >
            Upgrade Scan
          </Button>
        )}
      </div>
    </div>
  )
}


=== ./components/dashboard/source-detail.tsx ===

// source-detail.tsx

import React from 'react'
import { type MergedSource } from '@/lib/schemas'

interface SourceDetailProps {
  source: MergedSource
}

export function SourceDetail({ source }: SourceDetailProps) {
  const supportsLabel = source.stance === 'support' ? 'Supports' : 'Does not support';
  const supportsColor = source.stance === 'support' ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700';

  return (
    <div>
      <div className="flex flex-wrap items-baseline gap-x-2 text-xs text-gray-600">
        <span className="font-medium">Source #{source.sourceNumber}</span>
        <span className="text-gray-500">Pertinence: {source.pertinence}%</span>
        <span className="text-gray-500">Agreement: {source.agreementPercentage}%</span>
      </div>
      <a
        href={source.url}
        target="_blank"
        rel="noopener noreferrer"
        className="block text-sm font-medium text-blue-700 hover:underline mt-1"
      >
        {source.title || 'Untitled Source'}
      </a>
      <p className="mt-1 text-sm text-gray-600">
        "{source.relevantSnippet}"
      </p>
      <span className={`inline-block mt-1 rounded px-1 text-xs font-medium ${supportsColor}`}>
        {supportsLabel}
      </span>
    </div>
  );
}

=== ./components/dashboard/single-claim-view.tsx ===

import React from 'react'
import { Button } from "@/components/ui/button"
import { ArrowLeft } from 'lucide-react'
import { type Claim } from '@/lib/schemas'
import { ClaimCard } from './claim-card'

interface SingleClaimViewProps {
  claim: Claim
  onBack: () => void
}

export const SingleClaimView: React.FC<SingleClaimViewProps> = ({ claim, onBack }) => {
  return (
    <div className="space-y-4">
      <Button
        variant="ghost"
        size="sm"
        onClick={onBack}
        className="mb-2"
      >
        <ArrowLeft className="mr-2 h-4 w-4" />
        Back
      </Button>
      
      <ClaimCard
        claim={claim}
        isActive={false}
        isExpanded={true}
        onClick={() => {}}
      />
    </div>
  )
}

=== ./components/UpgradeModal.tsx ===

"use client";

import * as React from "react";
import { X, Check } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Drawer, DrawerContent, DrawerHeader, DrawerTitle, DrawerFooter, DrawerClose, DrawerTrigger } from "@/components/ui/drawer";
import { Badge } from "@/components/ui/badge";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { loadStripe } from "@stripe/stripe-js";
import useMediaQuery from "@/lib/hooks/use-media-query";
import { useToast } from "@/hooks/use-toast";
import { createStripeCheckoutSession } from "@/lib/actions/stripe-actions";
import { NiceBlueButton } from "./ui/nice-blue-button";

const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!);

export default function UpgradeModal() {
  const [open, setOpen] = React.useState(false);
  const [plans, setPlans] = React.useState<any[]>([]);
  const [plan, setPlan] = React.useState("");
  const { isMobile } = useMediaQuery();
  const { toast } = useToast();

  React.useEffect(() => {
    const fetchPlans = async () => {
      try {
        const response = await fetch('/api/plans');
        const data = await response.json();
        setPlans(data);
        // Set the first plan as default when plans are loaded
        if (data.length > 0) {
          setPlan(data[0].id);
        }
      } catch (error) {
        console.error('Error fetching plans:', error);
      }
    };
    fetchPlans();
  }, []);

  const handleBuy = async (priceId: string) => {
    try {
      const { sessionId } = await createStripeCheckoutSession([{
        price: priceId,
        quantity: 1
      }]);
      const stripe = await stripePromise;
      if (!stripe || !sessionId) {
        throw new Error("Stripe or sessionId not available");
      }

      const { error } = await stripe.redirectToCheckout({ sessionId });
      if (error) {
        throw new Error(error.message);
      }
    } catch (error: any) {
      toast({
        variant: "destructive",
        title: "Error",
        description: error?.message || "Something went wrong with the subscription!"
      });
    }
  };

  const content = (
    <div className="px-4 py-2 space-y-4">
      <div className="animate-fade-up opacity-0" style={{ animationDelay: "0ms" }}>
        <p className="text-sm text-muted-foreground">
          Instantly verify claims, boost credibility, and excel in your writing with our AI-powered fact-checker.
        </p>
      </div>

      <div className="animate-fade-up opacity-0 space-y-2" style={{ animationDelay: "100ms" }}>
        <h3 className="text-sm font-semibold">Premium Plan Includes:</h3>
        <ul className="text-sm space-y-1">
          <li><Check className="inline h-4 w-4 text-blue-500 mr-1" /> 20,000 monthly credits (2k fact checks)</li>
          <li><Check className="inline h-4 w-4 text-blue-500 mr-1" /> Advanced claim verification</li>
          <li><Check className="inline h-4 w-4 text-blue-500 mr-1" /> Credibility analysis</li>
          <li><Check className="inline h-4 w-4 text-blue-500 mr-1" /> Citation suggestions</li>
        </ul>
      </div>

      <div className="animate-fade-up opacity-0 bg-gray-50 border rounded-lg p-3 text-sm italic text-muted-foreground" style={{ animationDelay: "200ms" }}>
        "I rely on this for every research paperit's saved me countless hours and made my work more credible."
        <div className="mt-1 font-medium text-black"> Sarah, Researcher</div>
      </div>

      <RadioGroup value={plan} onValueChange={setPlan} className="animate-fade-up opacity-0 space-y-2" style={{ animationDelay: "300ms" }}>
        {plans.map((planOption) => (
          <div key={planOption.id} className={`flex items-center space-x-2 rounded-md border p-3 ${plan === planOption.id ? 'border-blue-500 bg-blue-50' : ''}`}>
            <RadioGroupItem value={planOption.id} id={planOption.id} className="w-5 h-5 border-2 border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 checked:border-blue-500 checked:bg-blue-500" />
            <div className="flex-1">
              <Label htmlFor={planOption.id} className="text-sm font-medium flex items-center">
                {planOption.name}
                {planOption.interval === 'year' && <Badge className="ml-1 text-[10px] py-0 px-1">SAVE 25%</Badge>}
              </Label>
              <div className="text-xs text-muted-foreground">${(planOption.price / 100).toFixed(2)} / {planOption.interval}</div>
              <div className="text-xs text-muted-foreground">20,000 credits/month</div>
            </div>
          </div>
        ))}
      </RadioGroup>
    </div>
  );

  if (isMobile) {
    return (
      <Drawer open={open} onOpenChange={setOpen}>
        <DrawerTrigger asChild>
          <Button variant="outline">Upgrade to Premium</Button>
        </DrawerTrigger>
        <DrawerContent className="fixed inset-x-0 bottom-0 mt-24 rounded-t-[10px] max-h-[96vh]">
          <div className="max-w-md mx-auto h-full overflow-y-auto">
            <DrawerHeader className="text-left p-4 pb-2">
              <div className="flex items-center justify-between mb-2">
                <Badge variant="secondary" className="bg-blue-100 text-blue-800 hover:bg-blue-100">
                  PREMIUM
                </Badge>
                <DrawerClose className="rounded-full opacity-70 hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2">
                  <X className="h-4 w-4" />
                  <span className="sr-only">Close</span>
                </DrawerClose>
              </div>
              <DrawerTitle className="text-xl font-bold tracking-tight">
                Elevate Your Writing with Verified Facts
              </DrawerTitle>
            </DrawerHeader>
            {content}
            <DrawerFooter className="px-4 py-4">
              <NiceBlueButton
                className="w-full"
                onClick={() => {
                  const selectedPlan = plans.find(p => p.id === plan);
                  if (selectedPlan) {
                    handleBuy(selectedPlan.price_id);
                  }
                }}
              >
                Upgrade to Premium
              </NiceBlueButton>
            </DrawerFooter>
          </div>
        </DrawerContent>
      </Drawer>
    );
  }

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button variant="outline">Upgrade to Premium</Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[600px]">
        <DialogHeader className="text-left p-4 pb-2">
          <div className="flex items-center justify-between mb-2">
            <Badge variant="secondary" className="bg-blue-100 text-blue-800 hover:bg-blue-100">
              PREMIUM
            </Badge>
          </div>
          <DialogTitle className="text-xl font-bold tracking-tight">
            Elevate Your Writing with Verified Facts
          </DialogTitle>
        </DialogHeader>
        {content}
        <div className="p-4 mt-4">
          <NiceBlueButton
            className="w-full"
            onClick={() => {
              const selectedPlan = plans.find(p => p.id === plan);
              if (selectedPlan) {
                handleBuy(selectedPlan.price_id);
              }
            }}
          >
            Upgrade to Premium
          </NiceBlueButton>
        </div>
      </DialogContent>
    </Dialog>
  );
}

=== ./components/textarea-landing.tsx ===

// app/components/FactCheckTool.tsx
"use client";

import * as React from "react";
import { useState, FormEvent, useRef, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Textarea } from "@/components/ui/textarea";
import { ArrowRight } from "lucide-react";
import { useRouter } from "next/navigation";

export default function FactCheckTool() {
  const router = useRouter();
  const [articleContent, setArticleContent] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();

    if (!articleContent) {
      setError("Please enter some content or try with sample blog.");
      return;
    }

    if (articleContent.length < 50) {
      setError("Too short. Please enter at least 50 characters.");
      return;
    }

    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch("/api/submit", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ content: articleContent }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Something went wrong");
      }

      router.push(`/dashboard?id=${data.id}`);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to submit content");
    } finally {
      setIsSubmitting(false);
    }
  };

  const sampleBlog = `The Eiffel Tower, a remarkable iron lattice structure standing proudly in Paris, was originally built as a giant sundial in 1822, intended to cast shadows across the city to mark the hours. Designed by the renowned architect Gustave Eiffel, the tower stands 324 meters tall and once housed the city's first observatory.\n\nWhile it's famously known for hosting over 7 million visitors annually, it was initially disliked by Parisians. Interestingly, the Eiffel Tower was used as to guide ships along the Seine during cloudy nights.`;

  return (
    <div className="max-w-3xl mx-auto">
      <Card className="overflow-hidden border-neutral-200/70 bg-white/70 backdrop-blur-sm shadow-[0_0_1px_rgba(0,0,0,0.04),0_2px_4px_rgba(0,0,0,0.04)] transition-all hover:shadow-[0_0_1px_rgba(0,0,0,0.04),0_4px_8px_rgba(0,0,0,0.08)]">
        <form onSubmit={handleSubmit}>
          <div className="px-6 py-5">
            <Textarea
              ref={textareaRef}
              value={articleContent}
              onChange={(e) => setArticleContent(e.target.value)}
              placeholder="Paste your content here..."
              className="min-h-[200px] resize-none border-0 bg-transparent p-0 text-[15px] leading-relaxed placeholder:text-neutral-400 focus-visible:ring-0"
            />
          </div>
          <div className="flex items-center justify-between border-t border-neutral-200/70 bg-neutral-50/50 px-6 py-4">
            <Button
              type="button"
              variant="ghost"
              onClick={() => setArticleContent(sampleBlog)}
              className="text-[13px] font-normal text-neutral-600 hover:bg-neutral-100 hover:text-neutral-900 transition-all duration-200"
              disabled={isSubmitting}
            >
              Try a sample
            </Button>
            <Button
              type="submit"
              className="relative overflow-hidden bg-neutral-900 px-5 py-2.5 text-[13px] font-medium text-white transition-all hover:bg-neutral-800 shadow-[0_2px_4px_rgba(0,0,0,0.04),0_4px_8px_rgba(0,0,0,0.08)] hover:shadow-[0_4px_8px_rgba(0,0,0,0.08),0_8px_16px_rgba(0,0,0,0.08)] active:translate-y-[1px] active:shadow-[inset_0_1px_2px_rgba(0,0,0,0.2)]"
              disabled={isSubmitting}
            >
              {isSubmitting ? "Submitting..." : "Verify Now"}
              <ArrowRight className="ml-2 h-3.5 w-3.5 transition-transform duration-200 group-hover:translate-x-0.5" />
            </Button>
          </div>
        </form>
      </Card>

      {error && (
        <div className="mt-8">
          <Card className="border-red-200 bg-red-50/50 p-4 text-red-700">
            {error}
          </Card>
        </div>
      )}
    </div>
  );
}
=== ./components/Landing.tsx ===

// app/components/LandingPage.tsx
"use client";

import * as React from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { 
  FileCheck, 
  Search, 
  Database, 
  CheckCircle, 
  ExternalLink,
  AlertTriangle
} from 'lucide-react';
import FactCheckTool from "./textarea-landing";

const howItWorks = [
  {
    title: "Paste Your Text",
    description: "Drop in your article, essay, or claims that need verification.",
    icon: FileCheck,
  },
  {
    title: "AI Analysis",
    description: "Our AI identifies key facts and checks them against trusted sources.",
    icon: Search,
  },
  {
    title: "Get Results",
    description: "Review the verification report with confidence scores and sources.",
    icon: Database,
  },
];

const benefits = [
  {
    title: "Save Hours of Research",
    description: "Stop manually fact-checking. Let AI handle the heavy lifting while you focus on writing.",
    icon: FileCheck,
  },
  {
    title: "Build Trust & Credibility",
    description: "Every claim is verified against reliable sources, giving your content authority.",
    icon: CheckCircle,
  },
  {
    title: "Write with Confidence",
    description: "Know that your content is accurate before you publish, every single time.",
    icon: ExternalLink,
  },
];

const testimonials = [
  {
    quote: "FactFilter has transformed our editorial process. What used to take hours now takes minutes.",
    name: "Sarah Johnson",
    title: "Editor at TechDaily"
  },
  {
    quote: "The accuracy and speed of verification have made this an essential tool for our research team.",
    name: "Michael Chen",
    title: "Research Director"
  },
  {
    quote: "We've cut our fact-checking time by 80% while improving accuracy. It's a game-changer.",
    name: "Emily Rodriguez",
    title: "Content Strategy Lead"
  },
];

export default function LandingPage() {
  return (
    <div className="relative min-h-screen overflow-hidden">
      {/* Background pattern */}
      <div 
        className="pointer-events-none absolute inset-0 bg-[linear-gradient(to_right,#80808002_1px,transparent_1px),linear-gradient(to_bottom,#80808002_1px,transparent_1px)] bg-[size:14px_24px]"
        style={{
          mask: 'radial-gradient(circle at center, white 60%, transparent 100%)',
          WebkitMask: 'radial-gradient(circle at center, white 60%, transparent 100%)',
          backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noiseFilter)' opacity='0.015'/%3E%3C/svg%3E")`,
        }}
      />

      <div className="relative mx-auto max-w-7xl px-6 py-20">
        {/* Hero Section */}
        <div className="text-center max-w-[640px] mx-auto">
          <div className="inline-flex items-center justify-center">
            <span className="inline-flex items-center rounded-full border border-neutral-200/70 bg-white px-3 py-1 text-sm text-neutral-600 shadow-[0_1px_2px_rgba(0,0,0,0.04)] transition-all hover:shadow-[0_3px_10px_rgba(0,0,0,0.04)] hover:border-neutral-300/70">
               <span className="mx-2 h-3 w-px bg-neutral-200" /> Powered by Exa
            </span>
          </div>
          <h1 className="mt-6 text-[2.75rem] font-bold tracking-tight text-neutral-900 sm:text-5xl md:text-6xl [text-wrap:balance] [-webkit-text-stroke:1px_#000000] [text-shadow:0_4px_4px_rgba(0,0,0,0.05)]">
            Transform Your Text into Trustworthy Content
          </h1>
          <p className="mx-auto mt-6 max-w-2xl text-lg leading-relaxed text-neutral-600 [text-wrap:balance]">
            Instantly verify facts and sources in your writing. No more guessworkjust credible, accurate content that builds trust with your audience.
          </p>
        </div>

        {/* Fact Check Tool */}
        <div className="mt-10">
          <FactCheckTool />
        </div>

        {/* Trust Signals */}
        <div className="mt-16 space-y-4 text-center">
          <p className="text-sm text-neutral-600">
            Trusted by writers, researchers, and professionals worldwide
          </p>
          <div className="flex justify-center gap-x-8 grayscale opacity-80">
            {['Vercel', 'Raycast', 'Linear', 'Mercury'].map((company) => (
              <div key={company} className="text-neutral-400 hover:opacity-75 transition-opacity duration-200">
                {company}
              </div>
            ))}
          </div>
        </div>

        {/* How It Works + Demo */}
        <div className="mt-32 max-w-5xl mx-auto">
          <div className="text-center space-y-4 mb-16">
            <h2 className="text-3xl font-semibold text-neutral-900 tracking-tight">How It Works</h2>
            <p className="text-neutral-600 max-w-xl mx-auto [text-wrap:balance] leading-relaxed">
              FactFilter simplifies verification into a few easy stepstry it yourself and see instant results.
            </p>
          </div>

          <div className="grid md:grid-cols-3 gap-8">
            {howItWorks.map((step, i) => (
              <div key={i} className="relative group">
                <div className="absolute -top-4 right-4 text-neutral-300 text-7xl font-bold">
                  {i + 1}
                </div>
                <Card className="relative h-full border-neutral-200/70 bg-white/70 p-6 shadow-[0_0_1px_rgba(0,0,0,0.04),0_2px_4px_rgba(0,0,0,0.04)]">
                  <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-neutral-100 transition-colors duration-300 group-hover:bg-neutral-200">
                    <step.icon className="h-6 w-6 text-neutral-600" />
                  </div>
                  <h3 className="text-lg font-medium text-neutral-900 mb-2">{step.title}</h3>
                  <p className="text-sm text-neutral-600 leading-relaxed">{step.description}</p>
                </Card>
              </div>
            ))}
          </div>

          {/* Inline Demo */}
          <Card className="mt-16 mx-auto max-w-2xl border-neutral-200/70 bg-white/70 shadow-[0_0_1px_rgba(0,0,0,0.04),0_2px_4px_rgba(0,0,0,0.04)] p-6 hover:shadow-[0_0_1px_rgba(0,0,0,0.04),0_4px_8px_rgba(0,0,0,0.08)] transition-all duration-300">
            <div className="space-y-4">
              <div className="space-y-2">
                <div className="flex items-center space-x-2">
                  <div className="h-2 w-2 rounded-full bg-green-500 animate-pulse" />
                  <p className="text-sm font-medium text-neutral-600">Live Example</p>
                </div>
                <p className="text-neutral-700 leading-relaxed">
                  <span className="bg-green-100/50 px-1 py-0.5 rounded">"The Eiffel Tower is 324 meters tall."</span>
                  {' '}
                  <span className="bg-yellow-100/50 px-1 py-0.5 rounded">"It was built in 1887."</span>
                </p>
              </div>
              
              <div className="space-y-3 text-sm border-t border-neutral-200/70 pt-4">
                <div className="flex items-start">
                  <CheckCircle className="text-green-500 mr-2 mt-0.5 h-4 w-4 flex-shrink-0" />
                  <p><span className="font-medium text-neutral-900">Verified:</span> The Eiffel Tower is ~324 meters tall.</p>
                </div>
                <div className="flex items-start">
                  <AlertTriangle className="text-yellow-500 mr-2 mt-0.5 h-4 w-4 flex-shrink-0" />
                  <p><span className="font-medium text-neutral-900">Needs refinement:</span> Construction began in 1887 but completed in 1889.</p>
                </div>
              </div>
            </div>
          </Card>
        </div>

        {/* Benefits Section */}
        <div className="mt-32">
          <div className="text-center space-y-4 mb-16">
            <h2 className="text-3xl font-semibold text-neutral-900 tracking-tight">Key Benefits</h2>
            <p className="text-neutral-600 max-w-xl mx-auto [text-wrap:balance] leading-relaxed">
              Experience the power of AI-driven fact-checking that saves time and builds trust.
            </p>
          </div>

          <div className="grid gap-6 sm:grid-cols-3 max-w-5xl mx-auto">
            {benefits.map((benefit, i) => (
              <Card 
                key={i} 
                className="relative border-neutral-200/70 bg-white/70 p-6 shadow-[0_0_1px_rgba(0,0,0,0.04),0_2px_4px_rgba(0,0,0,0.04)]"
              >
                <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-neutral-100 transition-colors duration-300 group-hover:bg-neutral-200">
                  <benefit.icon className="h-6 w-6 text-neutral-600" />
                </div>
                <h3 className="text-lg font-medium text-neutral-900 mb-2">{benefit.title}</h3>
                <p className="text-sm text-neutral-600 leading-relaxed">{benefit.description}</p>
              </Card>
            ))}
          </div>
        </div>

        {/* Testimonials */}
        <div className="mt-32 max-w-6xl mx-auto">
          <div className="text-center space-y-4 mb-16">
            <h2 className="text-3xl font-semibold text-neutral-900 tracking-tight">Trusted by Industry Leaders</h2>
            <p className="text-neutral-600 max-w-xl mx-auto [text-wrap:balance] leading-relaxed">
              See why professionals choose FactFilter for their content verification needs.
            </p>
          </div>

          <div className="grid md:grid-cols-3 gap-8">
            {testimonials.map((t, idx) => (
              <Card key={idx} className="p-6 border-neutral-200/70 bg-white/70 shadow-[0_0_1px_rgba(0,0,0,0.04),0_2px_4px_rgba(0,0,0,0.04)]">
                <div className="mb-4">
                  <p className="text-neutral-600 text-sm leading-relaxed">{t.quote}</p>
                </div>
                <div className="flex items-center">
                  <div className="w-10 h-10 bg-neutral-100 rounded-full mr-3 flex items-center justify-center text-neutral-600 font-medium text-sm">
                    {t.name[0]}
                  </div>
                  <div>
                    <p className="font-medium text-sm text-neutral-900">{t.name}</p>
                    <p className="text-xs text-neutral-500">{t.title}</p>
                  </div>
                </div>
              </Card>
            ))}
          </div>
        </div>

        {/* CTA Section */}
        <div className="mt-32 text-center max-w-2xl mx-auto">
          <Card className="border-neutral-200/70 bg-white/70 p-8 shadow-[0_0_1px_rgba(0,0,0,0.04),0_4px_8px_rgba(0,0,0,0.08)] transition-all duration-300 hover:shadow-[0_0_1px_rgba(0,0,0,0.04),0_8px_16px_rgba(0,0,0,0.08)]">
            <h2 className="text-2xl font-semibold mb-4 text-neutral-900 tracking-tight">Ready to Try FactFilter?</h2>
            <p className="text-neutral-600 mb-6 [text-wrap:balance] leading-relaxed">
              Get started now with a free trialno credit card required, no commitments.
            </p>
            <Button 
              className="px-8 h-12 text-sm font-medium bg-neutral-900 text-white rounded-lg hover:bg-neutral-800 transition-all duration-300 shadow-[0_2px_4px_rgba(0,0,0,0.04),0_4px_8px_rgba(0,0,0,0.08)] hover:shadow-[0_4px_8px_rgba(0,0,0,0.08),0_8px_16px_rgba(0,0,0,0.08)] active:translate-y-[1px] active:shadow-[inset_0_1px_2px_rgba(0,0,0,0.2)]"
            >
              Start Your Free Trial
            </Button>
            <p className="mt-4 text-sm text-neutral-500">Get 5 free verifications  Upgrade anytime</p>
          </Card>
        </div>
      </div>
    </div>
  );
}
=== ./hooks/use-toast.ts ===

"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

=== ./lib/schemas.ts ===

// lib/schemas.ts
import { z } from 'zod';

// -----------------------------------
// Final Data Structures
// -----------------------------------

export const ClaimStatusSchema = z.enum([
  'supported',
  'debated', 
  'contradicted',
  'insufficient information',
  'not yet verified'
]);
export type ClaimStatus = z.infer<typeof ClaimStatusSchema>;

export const SourceStanceSchema = z.enum([
  'support',
  'contradict',
  'not relevant',
  'unclear'
]);
export type SourceStance = z.infer<typeof SourceStanceSchema>;

export const MergedSourceSchema = z.object({
  url: z.string().url(),
  title: z.string().optional(),
  sourceNumber: z.number(),
  sourceText: z.string(),
  stance: SourceStanceSchema,
  agreementPercentage: z.number().min(0).max(100),
  pertinence: z.number().min(0).max(100),
  relevantSnippet: z.string().optional()
});
export type MergedSource = z.infer<typeof MergedSourceSchema>;

export const ClaimSchema = z.object({
  id: z.number(),
  exactText: z.string(),
  claim: z.string(),
  start: z.number(),
  end: z.number(),
  status: ClaimStatusSchema,
  confidence: z.number().min(0).max(100).nullable(),
  explanation: z.string().nullable(),
  sources: z.array(MergedSourceSchema),
  suggestedFix: z.string().optional(),
  searchQuery: z.string()
});
export type Claim = z.infer<typeof ClaimSchema>;

// -----------------------------------
// LLM Extraction Schemas
// -----------------------------------
export const LLMExtractedClaimSchema = z.object({
  claim: z.string().describe(
    "The extracted claim in a single verifiable statement. Should include all information necessary to verify the statement in isolation."
  ),
  exactText: z.string().describe(
    "The original portion of text that contains the claim. Must be a continuous, uninterrupted sequence from the source text."
  ),
  searchQuery: z.string().describe(
    "A specific question formatted to help verify the claim when searched"
  )
});
export type LLMExtractedClaim = z.infer<typeof LLMExtractedClaimSchema>;

export const LLMExtractedClaimsResponseSchema = z.object({
  claims: z.array(z.object({
    ...LLMExtractedClaimSchema.shape,
    start: z.number(),
    end: z.number()
  }))
});
export type LLMExtractedClaimsResponse = z.infer<typeof LLMExtractedClaimsResponseSchema>;

// -----------------------------------
// Combined Search+Verify Step Schemas
// -----------------------------------

// Input to Search+Verify endpoint:
// We assume the claims here come from after extraction and initialization.
// i.e., we know id, exactText, claim, start, end, but not final sources.
// status is 'not yet verified', etc. This endpoint will handle search and verify.
export const SearchAndVerifyRequestSchema = z.object({
  claims: z.array(z.object({
    id: z.number(),
    exactText: z.string(),
    claim: z.string(),
    searchQuery: z.string(),
    start: z.number(),
    end: z.number(),
  }))
});
export type SearchAndVerifyRequest = z.infer<typeof SearchAndVerifyRequestSchema>;

// Output is final enriched Claim arrays
export const SearchAndVerifyResponseSchema = z.object({
  claims: z.array(ClaimSchema)
});
export type SearchAndVerifyResponse = z.infer<typeof SearchAndVerifyResponseSchema>;

// -----------------------------------
// Intermediate Schemas for Internal Steps
// -----------------------------------

// Exa source (search step result) before merging:
export const ExaSourceSchema = z.object({
  url: z.string().url(),
  title: z.string().optional(),
  sourceNumber: z.number(),
  sourceText: z.string()
});
export type ExaSource = z.infer<typeof ExaSourceSchema>;

// LLM verification cited source (no text fields):
export const LLMCitedSourceSchema = z.object({
  sourceNumber: z.number().describe('The index number of the source, matching ExaSource sourceNumber'),
  stance: SourceStanceSchema.describe('Whether this source supports or contradicts the claim'),
  agreementPercentage: z.number().min(0).max(100).describe('How strongly this source agrees with the claim, from 0-100%'),
  pertinence: z.number().min(0).max(100).describe('How relevant this source is to the claim topic, from 0-100%'), 
  relevantSnippet: z.string().describe('The specific text excerpt from the source that relates to the claim')
});
export type LLMCitedSource = z.infer<typeof LLMCitedSourceSchema>;

// LLM verification result for a single claim:
export const LLMVerificationResultSchema = z.object({
  status: ClaimStatusSchema.describe('The verification status of the claim: supported, contradicted, debated, or insufficient information'),
  confidence: z.number().min(0).max(100).describe('Confidence score from 0-100 indicating how confident the verification is'),
  explanation: z.string().describe('Detailed explanation of the verification result, with source references like {{1}}, {{2}}'),
  suggestedFix: z.string().optional().describe('If status is contradicted, provides corrected version of the claim text'),
  citedSources: z.array(LLMCitedSourceSchema).describe('Array of sources cited in the explanation, with stance and relevance metrics'),
  searchQuery: z.string().describe('The search query used to verify the claim')
});
export type LLMVerificationResult = z.infer<typeof LLMVerificationResultSchema>;

=== ./lib/utils.ts ===

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
=== ./lib/types.ts ===

// lib/types.ts
import { z } from 'zod';
import * as Schemas from '@/lib/schemas';

// Export Types
export type ExaSource = z.infer<typeof Schemas.ExaSourceSchema>;
export type Claim = Schemas.Claim;
export type LLMExtractedClaim = z.infer<typeof Schemas.LLMExtractedClaimSchema>;
export type LLMExtractedClaimsResponse = z.infer<typeof Schemas.LLMExtractedClaimsResponseSchema>;

export type SearchAndVerifyRequest = z.infer<typeof Schemas.SearchAndVerifyRequestSchema>;
export type SearchAndVerifyResponse = z.infer<typeof Schemas.SearchAndVerifyResponseSchema>;

export type LLMVerificationResult = z.infer<typeof Schemas.LLMVerificationResultSchema>;
export type ClaimStatus = z.infer<typeof Schemas.ClaimStatusSchema>;
export type LLMCitedSource = z.infer<typeof Schemas.LLMCitedSourceSchema>;
export type MergedSource = z.infer<typeof Schemas.MergedSourceSchema>;

=== ./lib/hooks/use-scroll.ts ===

import { useCallback, useEffect, useState } from "react";

export default function useScroll(threshold: number) {
  const [scrolled, setScrolled] = useState(false);

  const onScroll = useCallback(() => {
    setScrolled(window.pageYOffset > threshold);
  }, [threshold]);

  useEffect(() => {
    window.addEventListener("scroll", onScroll);
    return () => window.removeEventListener("scroll", onScroll);
  }, [onScroll]);

  return scrolled;
}
=== ./lib/hooks/use-media-query.ts ===

import { useEffect, useState } from "react";

export default function useMediaQuery() {
  const [device, setDevice] = useState<"mobile" | "tablet" | "desktop" | null>(
    null,
  );
  const [dimensions, setDimensions] = useState<{
    width: number;
    height: number;
  } | null>(null);

  useEffect(() => {
    const checkDevice = () => {
      if (window.matchMedia("(max-width: 640px)").matches) {
        setDevice("mobile");
      } else if (
        window.matchMedia("(min-width: 641px) and (max-width: 1024px)").matches
      ) {
        setDevice("tablet");
      } else {
        setDevice("desktop");
      }
      setDimensions({ width: window.innerWidth, height: window.innerHeight });
    };

    // Initial detection
    checkDevice();

    // Listener for windows resize
    window.addEventListener("resize", checkDevice);

    // Cleanup listener
    return () => {
      window.removeEventListener("resize", checkDevice);
    };
  }, []);

  return {
    device,
    width: dimensions?.width,
    height: dimensions?.height,
    isMobile: device === "mobile",
    isTablet: device === "tablet",
    isDesktop: device === "desktop",
  };
}
=== ./lib/actions/stripe-actions.ts ===

'use server'

import { clerkClient, currentUser, auth } from '@clerk/nextjs/server'

import Stripe from 'stripe'
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {
  apiVersion: '2024-11-20.acacia'
})

type LineItem = Stripe.Checkout.SessionCreateParams.LineItem

export async function createStripeCheckoutSession(lineItems: LineItem[]) {
  const user = await currentUser()
  if (!user) {
    return { sessionId: null, checkoutError: 'You need to sign in first.' }
  }

  const origin = process.env.NEXT_PUBLIC_APP_URL as string

  const { userId } = await auth();

  const session = await stripe.checkout.sessions.create({
    mode: 'subscription',
    line_items: lineItems,
    success_url: `${origin}/checkout?sessionId={CHECKOUT_SESSION_ID}`,
    cancel_url: origin,
    customer_email: user.emailAddresses[0].emailAddress,
    metadata: {
      userId: userId,
    },
  })

  return { sessionId: session.id, checkoutError: null }
}

export async function retrieveStripeCheckoutSession(sessionId: string) {
  if (!sessionId) {
    return { success: false, error: 'No session ID provided.' }
  }

  const user = await currentUser()
  if (!user) {
    return { success: false, error: 'You need to sign in first.' }
  }

  const previousCheckoutSessionIds = Array.isArray(
    user.publicMetadata.checkoutSessionIds
  )
    ? user.publicMetadata.checkoutSessionIds
    : []

  if (previousCheckoutSessionIds.includes(sessionId)) {
    return {
      success: true,
      error: null
    }
  }

  const session = await stripe.checkout.sessions.retrieve(sessionId, {
    expand: ['subscription']
  })

  const clerk = await clerkClient()
  await clerk.users.updateUserMetadata(user.id, {
    publicMetadata: {
      checkoutSessionIds: [...previousCheckoutSessionIds, sessionId],
      stripeCustomerId: session.customer,
      stripeSubscriptionId:
        typeof session.subscription === 'string'
          ? session.subscription
          : session.subscription?.id,
      stripeCurrentPeriodEnd:
        typeof session.subscription === 'string'
          ? undefined
          : session.subscription?.current_period_end
    }
  })

  return { success: true, error: null }
}
=== ./drizzle.config.ts ===

import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  out: './drizzle',
  schema: './src/db/schema.ts',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});

=== ./src/db/schema.ts ===

import { pgTable, uuid, text, jsonb, timestamp } from 'drizzle-orm/pg-core';

export const submissions = pgTable('submissions', {
  id: uuid('id').defaultRandom().primaryKey(),
  content: text('content').notNull(),
  claims: jsonb('claims').default('[]'),
  createdAt: timestamp('created_at').defaultNow(),
});

export type Submission = typeof submissions.$inferSelect;
export type NewSubmission = typeof submissions.$inferInsert;
=== ./src/index.ts ===

import { drizzle } from 'drizzle-orm/neon-http';
import { eq } from 'drizzle-orm/expressions';
import { submissions, Submission, NewSubmission } from '@/src/db/schema';

if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL is not defined');
}

export const db = drizzle(process.env.DATABASE_URL);

// Function to save a new submission
export async function saveSubmission(newSubmission: NewSubmission): Promise<Submission> {
    const insertedSubmissions = await db.insert(submissions).values(newSubmission).returning();
    return insertedSubmissions[0];
}

// Function to get a submission by ID
export async function getSubmissionById(id: string): Promise<Submission | null> {
    const submissionsList = await db
        .select()
        .from(submissions)
        .where(eq(submissions.id, id));
    return submissionsList[0] || null;
}

// Function to update a submission with claims
export async function saveClaims(id: string, claims: any[]): Promise<void> {
    await db.update(submissions).set({ claims }).where(eq(submissions.id, id));
}